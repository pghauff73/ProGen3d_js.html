<!DOCTYPE html>
<!-- saved from url=(0036)https://34.69.10.227/grammar-reader/ -->
<html lang="en" data-theme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
		<link rel="stylesheet" href="./Grammar Reader WebGLr - Progen3d Visual Design_files/codemirror.min.css" integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ==" crossorigin="anonymous">
<script src="./Grammar Reader WebGLr - Progen3d Visual Design_files/codemirror.min.js.download" integrity="sha512-xwrAU5yhWwdTvvmMNheFn9IyuDbl/Kyghz2J3wQRDR8tyNmT8ZIYOd0V3iPYY/g4XdNPy0n/g0NvqGu9f0fPJQ==" crossorigin="anonymous">
</script>
<!--–– then load any modes you need, e.g. JavaScript: ––-->
<script src="./Grammar Reader WebGLr - Progen3d Visual Design_files/javascript.min.js.download" integrity="sha512-IS1FyxQkiJHT1SAvLXBaJu1UTFSIw0GT/DuzxHl69djqyLoEwGmR2davcZUnB8M7ppi9nfTGZR/vdfqmWt+i6A==" crossorigin="anonymous">
</script>
          <link href="./Grammar Reader WebGLr - Progen3d Visual Design_files/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
        <title>
            
            Grammar Reader WebGLr
            
            
            
            - Progen3d Visual Design
            
        </title>

        
        <meta name="viewport" content="width=device-width, initial-scale=1">

        
        

        
        <link rel="stylesheet" href="https://34.69.10.227/static/css/style.css">
          <!-- AOS animations CSS -->
        <link rel="stylesheet" href="./Grammar Reader WebGLr - Progen3d Visual Design_files/aos.css" integrity="sha384-/rJKQnzOkEo+daG0jMjU1IwwY9unxt1NBw3Ef2fmOJ3PW/TfAg2KXVoWwMZQZtw9" crossorigin="anonymous">
        
        
        
        
    <style id="progen3d-dynamic-styles">
      /* Scroll Progress Bar */
      .progress-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: var(--accent-light, rgba(0, 150, 136, 0.2));
        z-index: 9999;
      }
      .progress-bar {
        width: 0;
        height: 100%;
        background: var(--accent, #009688);
        transition: width 0.2s ease-out;
      }

      /* Mobile menu overlay */
      .nav-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.5);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 8;
      }
      .nav-overlay.show {
        opacity: 1;
        pointer-events: auto;
      }

      /* Tilt effect containers */
      .tilt {
        transform-style: preserve-3d;
        will-change: transform;
        transition: transform 0.3s ease-out;
      }

      /* Smooth theme transition */
      :root {
        --theme-transition: background 0.3s ease, color 0.3s ease;
      }
      [data-theme] * {
        transition: var(--theme-transition);
      }
    </style><style id="progen3d-dynamic-styles">
      /* Scroll Progress Bar */
      .progress-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: var(--accent-light, rgba(0, 150, 136, 0.2));
        z-index: 9999;
      }
      .progress-bar {
        width: 0;
        height: 100%;
        background: var(--accent, #009688);
        transition: width 0.2s ease-out;
      }

      /* Mobile menu overlay */
      .nav-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.5);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 8;
      }
      .nav-overlay.show {
        opacity: 1;
        pointer-events: auto;
      }

      /* Tilt effect containers */
      .tilt {
        transform-style: preserve-3d;
        will-change: transform;
        transition: transform 0.3s ease-out;
      }

      /* Smooth theme transition */
      :root {
        --theme-transition: background 0.3s ease, color 0.3s ease;
      }
      [data-theme] * {
        transition: var(--theme-transition);
      }
    </style></head>

    <body class="" data-aos-easing="ease" data-aos-duration="400" data-aos-delay="0">
        
<!-- Wagtail user bar embed code -->

<wagtail-userbar><template shadowrootmode="open"><aside>
        <div class="w-userbar w-userbar--bottom-right w-theme-system w-density-default w-contrast-system" data-wagtail-userbar="" part="userbar" style="display: none;">
            <link rel="stylesheet" href="https://34.69.10.227/static/wagtailadmin/css/core.css?v=e20b281f">
            
            <div class="w-userbar-nav">

                <svg class="w-hidden">
                    <defs>
                        
                            <svg xmlns="http://www.w3.org/2000/svg" id="icon-wagtail-icon" viewBox="0 0 16 16">
    <!--! Custom icon -->
    <path d="M12.324 2.539c0 0.152-0.114 0.303-0.303 0.303-0.152 0-0.303-0.152-0.303-0.303 0-0.19 0.152-0.303 0.303-0.303 0.19 0 0.303 0.114 0.303 0.303zM12.437 5.421c0 0-0.417-1.896-2.92-1.403-0.228-0.872-0.19-1.517 0.341-2.086 0.759-0.796 1.972-0.379 1.972-0.379v-0.645c-0.417-0.19-0.834-0.228-1.252-0.228-1.631 0-2.541 1.214-2.92 2.048l-4.513 8.306 1.289-0.228-2.351 4.513 1.631-0.303 1.252-3.527c3.527 0 8.078-1.289 7.471-6.068zM13.954 3.828l-0.986-0.986-0.796 0.986zM5.535 10.465c0 0 0.152-0.038 0.341-0.076 0.19-0.076 0.493-0.114 0.834-0.228 0.19-0.038 0.379-0.114 0.569-0.152 0.19-0.076 0.417-0.152 0.607-0.228 0.228-0.114 0.417-0.19 0.607-0.303 0.228-0.114 0.417-0.265 0.607-0.379 0.038-0.038 0.114-0.076 0.152-0.114l0.114-0.114c0.114-0.114 0.19-0.19 0.265-0.265s0.152-0.19 0.228-0.265c0.038-0.038 0.076-0.076 0.114-0.152l0.038-0.076 0.038-0.038c0.038-0.076 0.076-0.114 0.076-0.152 0.038-0.038 0.076-0.114 0.076-0.152 0.038-0.038 0.038-0.038 0.038-0.076 0.038 0 0.038-0.038 0.038-0.076 0.038-0.038 0.038-0.076 0.076-0.114 0.038-0.114 0.076-0.19 0.114-0.303 0-0.076 0.038-0.152 0.076-0.265 0-0.076 0.038-0.152 0.038-0.228s0.038-0.152 0.038-0.228c0-0.076 0.038-0.152 0.038-0.228 0-0.038 0-0.114 0-0.152 0-0.19 0.038-0.341 0.038-0.341l0.19 0.038c0 0-0.038 0.114-0.038 0.303 0 0.076-0.038 0.114-0.038 0.19s0 0.152-0.038 0.19c0 0.076 0 0.152-0.038 0.265 0 0.076-0.038 0.152-0.038 0.228-0.038 0.114-0.076 0.19-0.114 0.303-0.038 0.076-0.076 0.19-0.114 0.265 0 0.038-0.038 0.114-0.076 0.152 0 0.038 0 0.038-0.038 0.076 0 0.038 0 0.038-0.038 0.076 0 0.038-0.038 0.076-0.076 0.152-0.038 0.038-0.038 0.076-0.076 0.114s-0.038 0.076-0.038 0.076l-0.076 0.076c-0.038 0.038-0.076 0.114-0.114 0.152-0.076 0.076-0.152 0.19-0.228 0.265s-0.152 0.152-0.265 0.265l-0.114 0.114c-0.076 0.038-0.114 0.038-0.152 0.076-0.228 0.152-0.417 0.303-0.645 0.417-0.19 0.076-0.417 0.19-0.607 0.265-0.228 0.076-0.417 0.152-0.645 0.228-0.19 0.038-0.379 0.114-0.569 0.152-0.341 0.076-0.645 0.152-0.834 0.19s-0.341 0.076-0.341 0.076z"></path>
</svg>

                            <svg id="icon-key" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! key (solid): Font Awesome Pro 6.4.0 --><path d="M336 352c97.2 0 176-78.8 176-176S433.2 0 336 0S160 78.8 160 176c0 18.7 2.9 36.8 8.3 53.7L7 391c-4.5 4.5-7 10.6-7 17v80c0 13.3 10.7 24 24 24h80c13.3 0 24-10.7 24-24V448h40c13.3 0 24-10.7 24-24V384h40c6.4 0 12.5-2.5 17-7l33.3-33.3c16.9 5.4 35 8.3 53.7 8.3zM376 96a40 40 0 1 1 0 80 40 40 0 1 1 0-80z"></path></svg>

                            <svg id="icon-folder-open-inverse" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19 16"><!--! folder-open (solid): Font Awesome Pro 6.4.0 --><path d="M4.594 6H15V4.5c0-.813-.688-1.5-1.5-1.5h-5l-2-2h-5A1.5 1.5 0 0 0 0 2.5v10.281l2.813-5.656A2.003 2.003 0 0 1 4.593 6Zm12.375 1H4.594a.962.962 0 0 0-.875.563L0 15h13.969c.375 0 .719-.188.875-.531l3-6A.986.986 0 0 0 16.969 7Z"></path></svg>

                            <svg id="icon-edit" class="icon--directional" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18"><!--! pen (solid): Font Awesome Pro 6.4.0 --><path d="M12.313 1.625a2.018 2.018 0 0 1 2.843 0l1.219 1.219a2.018 2.018 0 0 1 0 2.844l-1.5 1.5-4.063-4.063 1.5-1.5Zm1.843 6.281-7.281 7.282a2.722 2.722 0 0 1-1.156.687l-3.782 1.094a.638.638 0 0 1-.718-.188.708.708 0 0 1-.219-.718l1.125-3.782c.125-.437.375-.844.688-1.156l7.28-7.281 4.063 4.062Z"></path></svg>

                            <svg id="icon-plus" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><!--! plus (solid): Font Awesome Pro 6.4.0 --><path d="M14.5 8c0 .563-.469 1.031-1 1.031H9v4.5c0 .531-.469.969-1 .969a.98.98 0 0 1-1-.969v-4.5H2.5c-.563 0-1-.469-1-1.031a.98.98 0 0 1 1-.969H7v-4.5C7 1.97 7.438 1.5 8 1.5c.531 0 1 .469 1 1.031v4.5h4.5c.531-.031 1 .438 1 .969Z"></path></svg>

                            <svg id="icon-check" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><!--! check (solid): Font Awesome Pro 6.4.0 --><path d="M14.688 3.313a.964.964 0 0 1 0 1.406l-8 8a.964.964 0 0 1-1.407 0l-4-4a.964.964 0 0 1 0-1.406.964.964 0 0 1 1.407 0l3.28 3.28 7.313-7.28a.964.964 0 0 1 1.406 0Z"></path></svg>

                            <svg id="icon-cross" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><!--! xmark (solid): Font Awesome Pro 6.4.0 --><path d="M12.688 11.313a.964.964 0 0 1 0 1.406A.97.97 0 0 1 12 13a.99.99 0 0 1-.719-.281L8 9.438l-3.313 3.28A.97.97 0 0 1 4 13a.99.99 0 0 1-.719-.281.964.964 0 0 1 0-1.406L6.562 8l-3.28-3.281a.964.964 0 0 1 0-1.407.964.964 0 0 1 1.405 0L8 6.595l3.281-3.282a.964.964 0 0 1 1.406 0 .964.964 0 0 1 0 1.407L9.408 8.03l3.28 3.281Z"></path></svg>

                            <svg id="icon-crosshairs" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><!--! crosshairs (solid): Font Awesome Pro 6.4.0 --><path d="M7 8c0-.531.438-1 1-1 .531 0 1 .469 1 1 0 .563-.469 1-1 1-.563 0-1-.438-1-1Zm1-8c.531 0 1 .469 1 1v.344A6.764 6.764 0 0 1 14.656 7H15c.531 0 1 .469 1 1 0 .563-.469 1-1 1h-.344c-.437 2.938-2.75 5.25-5.656 5.688V15c0 .563-.469 1-1 1-.563 0-1-.438-1-1v-.313A6.762 6.762 0 0 1 1.312 9H1c-.563 0-1-.438-1-1 0-.531.438-1 1-1h.313C1.75 4.094 4.063 1.781 7 1.344V1c0-.531.438-1 1-1ZM7 12.656V12c0-.531.438-1 1-1 .531 0 1 .469 1 1v.656A4.685 4.685 0 0 0 12.625 9H12c-.563 0-1-.438-1-1 0-.531.438-1 1-1h.625A4.69 4.69 0 0 0 9 3.375V4c0 .563-.469 1-1 1-.563 0-1-.438-1-1v-.625A4.685 4.685 0 0 0 3.344 7H4c.531 0 1 .469 1 1 0 .563-.469 1-1 1h-.656A4.68 4.68 0 0 0 7 12.656Z"></path></svg>

                        
                    </defs>
                </svg>

                <button aria-controls="wagtail-userbar-items" aria-haspopup="true" class="w-userbar-trigger" id="wagtail-userbar-trigger" data-wagtail-userbar-trigger="" aria-expanded="false">
                    
<svg class="icon-wagtail w-userbar-icon" role="img" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 225 274" fill="none"><path fill="#fff" d="M194.897 79.492c-8.392-12.793-22.602-21.27-38.773-21.27-5.322 0-10.496.915-15.32 2.62a30.755 30.755 0 0 1-4.039-15.3c0-17.078 13.325-30.792 29.918-30.792 4.274 0 8.046.776 11.565 2.328 1.746-2.566 3.491-5.64 5.236-9.476 7.108 4.095 19.786 14.99 21.26 33.397L190.72 61.88l4.177 17.612Z"></path><path fill="#000" d="m49.277 186.425 8.718 18.407-1.743-30.679-6.975 12.272Z"></path><path fill="#000" d="m21.867 193.558 92.839-164.565C122.124 11.853 138.827 0 158.135 0c9.302 0 18.102 2.588 25.393 7.504-1.76 3.882-3.52 6.987-5.28 9.575-3.52-1.553-7.291-2.33-11.565-2.33-16.594 0-29.919 13.716-29.919 30.794 0 5.646 1.496 10.83 4.04 15.3a45.95 45.95 0 0 1 15.319-2.62c25.896 0 46.764 21.736 46.764 48.131 0 1.104-.183 2.209-.394 3.475l-.109.665h.252c-.126.906-.315 1.811-.503 2.717-.189.906-.377 1.811-.503 2.717v.259c-17.487 91.789-126.812 89.821-143.747 89.031l.112-.386-1.743-30.679-6.872 12.197-27.513 7.208Z"></path><path fill="#fff" d="m99.304 170.528-2.012 1.552s66.877-11.127 77.437-67.797l-10.56 3.623s-2.765 43.99-64.865 62.622Z"></path><path fill="#000" d="M185.54 42.697c3.332 0 6.034-2.781 6.034-6.211s-2.702-6.21-6.034-6.21c-3.333 0-6.034 2.78-6.034 6.21s2.701 6.21 6.034 6.21ZM204.648 41.144l-11.817 18.114h31.93l-20.113-18.114ZM56.252 174.153.456 273.202l41.847-14.025 15.692-54.345-1.743-30.679Z"></path></svg>

                    <span class="w-sr-only">View Wagtail quick actions</span>
                </button>
                <ul aria-labelledby="wagtail-userbar-trigger" class="w-userbar-items" id="wagtail-userbar-items" role="menu">
                    
                        <li class="w-userbar__item " role="presentation">
    
    <a href="https://34.69.10.227/admin/" target="_parent" role="menuitem" tabindex="-1">
        <svg class="icon icon-key w-action-icon" aria-hidden="true"><use href="#icon-key"></use></svg>
        Go to Wagtail admin
    </a>

</li>

                    
                        <li class="w-userbar__item " role="presentation">
    
    <a href="https://34.69.10.227/admin/pages/6/" target="_parent" role="menuitem" tabindex="-1">
        <svg class="icon icon-folder-open-inverse w-action-icon" aria-hidden="true"><use href="#icon-folder-open-inverse"></use></svg>
        Show in Explorer
    </a>

</li>

                    
                        <li class="w-userbar__item " role="presentation">
    
    <a href="https://34.69.10.227/admin/pages/29/edit/" target="_parent" role="menuitem" tabindex="-1">
        <svg class="icon icon-edit w-action-icon" aria-hidden="true"><use href="#icon-edit"></use></svg>
        Edit this page
    </a>

</li>

                    
                        <li class="w-userbar__item " role="presentation">
    
    <a href="https://34.69.10.227/admin/pages/29/add_subpage/" target="_parent" role="menuitem" tabindex="-1">
        <svg class="icon icon-plus w-action-icon" aria-hidden="true"><use href="#icon-plus"></use></svg>
        Add a child page
    </a>

</li>

                    
                        <li class="w-userbar__item " role="presentation">
    
    <button type="button" id="accessibility-trigger" role="menuitem" tabindex="-1">
        <span class="w-sr-only">Issues found</span><span class="w-a11y-result__count" data-a11y-result-count="">0</span>
        Accessibility
    </button>
    <script id="accessibility-axe-configuration" type="application/json">{"context": {"include": ["body"], "exclude": [{"fromShadowDOM": ["wagtail-userbar"]}]}, "options": {"runOnly": ["button-name", "empty-heading", "empty-table-header", "frame-title", "heading-order", "input-button-name", "link-name", "p-as-heading", "alt-text-quality"], "rules": {}}, "messages": {"button-name": {"error_name": "Button text is empty", "help_text": "Use meaningful text for screen reader users"}, "empty-heading": {"error_name": "Empty heading found", "help_text": "Use meaningful text for screen reader users"}, "empty-table-header": {"error_name": "Table header text is empty", "help_text": "Use meaningful text for screen reader users"}, "frame-title": {"error_name": "Empty frame title found", "help_text": "Use a meaningful title for screen reader users"}, "heading-order": {"error_name": "Incorrect heading hierarchy", "help_text": "Avoid skipping levels"}, "input-button-name": {"error_name": "Input button text is empty", "help_text": "Use meaningful text for screen reader users"}, "link-name": {"error_name": "Link text is empty", "help_text": "Use meaningful text for screen reader users"}, "p-as-heading": {"error_name": "Misusing paragraphs as headings", "help_text": "Use proper heading tags"}, "alt-text-quality": {"error_name": "Image alt text has inappropriate pattern", "help_text": "Use meaningful text"}}, "spec": {"rules": [{"id": "alt-text-quality", "impact": "serious", "selector": "img[alt]", "tags": ["best-practice"], "any": ["check-image-alt-text"], "enabled": true}], "checks": [{"id": "check-image-alt-text", "options": {"pattern": "\\.(avif|gif|jpg|jpeg|png|svg|webp)$|_"}}]}}</script>
    
    
    
    



</li>

                    
                </ul>
            </div>
        </div>
        <div data-a11y-result-outline-container=""></div>
    
    <div id="accessibility-results" aria-labelledby="title-accessibility-results" aria-hidden="true" class="w-dialog w-dialog--floating w-dialog--userbar w-theme-system w-density-default w-contrast-system" data-controller="w-dialog" data-action="w-dialog:hide-&gt;w-dialog#hide w-dialog:show-&gt;w-dialog#show" data-w-dialog-theme-value="floating" aria-modal="true" tabindex="-1" role="dialog">
        <div class="w-dialog__overlay" data-action="click-&gt;w-dialog#hide"></div>
        <div class="w-dialog__box">
            <button type="button" class="w-dialog__close-button" aria-label="Close dialog" data-action="w-dialog#hide">
                <svg class="icon icon-cross w-dialog__close-icon" aria-hidden="true"><use href="#icon-cross"></use></svg>
            </button>

            

            <div class="w-dialog__content">
                <div class="w-dialog__header">
                    <h2 class="w-dialog__title w-h1" id="title-accessibility-results">
                        
                        
                        <span id="title-text-accessibility-results">Warnings</span>
                    </h2>

                    
                        <p class="w-dialog__subtitle w-help-text" id="subtitle-accessibility-results">
        Issues found
        <span class="w-a11y-result__count" data-a11y-result-count="">0</span>
    </p>
                    
                </div>

                <div class="w-dialog__body" data-w-dialog-target="body">
                    
        
        <template id="w-a11y-result-row-template"></template>
        <template id="w-a11y-result-outline-template"></template>
    
                </div>
            </div>
        </div>
    </div>
</aside></template></wagtail-userbar>
<script src="https://34.69.10.227/static/wagtailadmin/js/vendor.js?v=e20b281f"></script>
<script src="https://34.69.10.227/static/wagtailadmin/js/userbar.js?v=e20b281f"></script>
<!-- end Wagtail user bar embed code -->


        
  <div class="html-section">
    <!-- ===== ProGen3d_js Title + Author (auto-typing) ===== -->
<link href="./Grammar Reader WebGLr - Progen3d Visual Design_files/css2" rel="stylesheet">

<section id="pg3d-hero" class="pg3d-hero">
  <div class="pg3d-hero__inner">
    <h1 class="pg3d-hero__title">
      <span id="pg3d-typed-title" aria-label="ProGen3d_js">ProGen3d_js</span>
    </h1>
    <p id="pg3d-author" class="pg3d-author show" aria-label="Author">Author: Ms Pamela G Hauff</p>
  </div>
</section>

<style>
  .pg3d-hero{
    background: radial-gradient(1200px 700px at 12% -10%, #1a2030 0%, transparent 60%),
                radial-gradient(1000px 600px at 110% 10%, #0c1220 0%, transparent 60%),
                linear-gradient(180deg, #0b0f18, #0b0f18);
    color:#e8edf7; padding:40px 20px; text-align:center; position:relative; overflow:hidden;
  }
  .pg3d-hero__inner{ max-width:1100px; margin:0 auto; }

  .pg3d-hero__title{
    font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    font-weight:900; font-size:clamp(3rem, 8vw, 8rem);
    letter-spacing:-0.03em; margin:0; min-height:1.2em; display:inline-block; position:relative;
  }
  /* Glowing cursor during typing */
  .pg3d-hero__title.typing::after{
    content:""; display:inline-block; width:0.55ch; height:0.9em; margin-left:0.12ch;
    vertical-align:-0.05em; border-radius:3px; background:#9fb8ff;
    box-shadow:0 0 6px rgba(159,184,255,.9), 0 0 16px rgba(110,168,254,.7), 0 0 42px rgba(114,227,166,.45);
    animation: pg3d-cursor-blink .9s steps(1,end) infinite;
  }
  @keyframes pg3d-cursor-blink { 0%,49%{opacity:1;} 50%,100%{opacity:.15;} }

  .pg3d-author{
    font-family:"Space Grotesk",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    font-size:clamp(1rem, 1.5vw, 1.25rem);
    color:#9fb0cc; margin:.75rem 0 0; opacity:0; transform:translateY(.25rem);
    transition:opacity .8s ease, transform .8s ease;
  }
  .pg3d-author.show{ opacity:1; transform:translateY(0); }
</style>

<script>
(function(){
  const titleEl = document.getElementById("pg3d-typed-title");
  const titleH1 = titleEl.parentElement; // .pg3d-hero__title
  const author  = document.getElementById("pg3d-author");

  const titleText = "ProGen3d_js";
  let i = 0;

  function typeTitle(){
    if (i < titleText.length){
      titleEl.textContent += titleText.charAt(i++);
      setTimeout(typeTitle, 120); // typing speed
    } else {
      // brief pause, then stop cursor and reveal author
      setTimeout(() => {
        titleH1.classList.remove("typing");
        author.classList.add("show");
      }, 400);
    }
  }

  typeTitle();
})();
</script>
<!-- ===== /Title + Author ===== -->
<style>
/* ===== Theme (keep variable names) ===== */
:root{
  --bg:#0f1116; --card:#171b26cc; --glass:rgba(23,27,38,0.82); --text:#e6e9ef; --muted:#9aa4b2;
  --accent:#6ea8fe; --accent-2:#72e3a6; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
  --green:#93f9b9; --blue:#8ab4ff; --orange:#ffb86b;
  /* derived */
  --border-soft: rgba(154,164,178,0.22); --border-med: rgba(154,164,178,0.26); --border-strong: rgba(154,164,178,0.30);
  --smart-bg: rgba(23,27,38,0.98); --smart-border: rgba(154,164,178,0.28); --smart-shadow: 0 10px 30px rgba(0,0,0,.35);
  /* compact toolbar sizing */
  --ctl-h: 32px; --ctl-gap: 6px; --btn-pad-x: 10px; --btn-radius: 10px;
  --inp-radius: 8px; --fz-ctl: 12.5px;
}
*{ box-sizing:border-box }
html,body{ height:100% }
body{
  margin:0; color:var(--text);
  background:
    radial-gradient(1200px 700px at 10% -10%, #1b2030 0%, transparent 40%),
    radial-gradient(1200px 700px at 110% 10%, #1a2a20 0%, transparent 40%),
    var(--bg);
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
}

/* ===== Layout ===== */
.wrap{
  --gap:18px; width:min(1400px,96vw); margin:28px auto;
  display:grid; gap:var(--gap);
  grid-template-columns: 1.0fr 1.2fr 1.4fr;
  grid-auto-rows: minmax(160px, auto);
}
@media (max-width:1200px){
  .wrap{ grid-template-columns:1fr 1fr }
  .viewer-card,.output-card{ grid-column:1/-1 }
}
@media (max-width:800px){ .wrap{ grid-template-columns:1fr } }

/* ===== Cards ===== */
.card{
  border-radius:var(--radius);
  background:linear-gradient(180deg, var(--glass), rgba(17,22,33,0.95));
  border:1px solid var(--border-soft); box-shadow:var(--shadow);
  overflow:hidden; -webkit-backdrop-filter: blur(6px) saturate(120%); backdrop-filter: blur(6px) saturate(120%);
}
.card header{
  padding:8px 12px; display:flex; align-items:center; justify-content:space-between; gap:10px;
  border-bottom:1px solid var(--border-soft);
}
.card h2{ margin:0; font-size:12px; text-transform:uppercase; letter-spacing:.14em; color:var(--muted); }
.card .body{ padding:14px; }

/* Section spans (keep names) */
.input-card{ grid-column:1 / span 2; }
.viewer-card{ grid-column:3 / span 1; }
.output-card{ grid-column:1 / -1; }

/* ===== Compact toolbar & inputs ===== */
.toolbar{ display:flex; align-items:center; flex-wrap:wrap; gap:var(--ctl-gap); }
#status{ font-size:11.5px; color:var(--muted); margin-right:4px; }
.text-input, .select-input{
  height:var(--ctl-h); min-width:200px; padding:0 10px; border-radius:var(--inp-radius);
  color:var(--text); background:rgba(255,255,255,.04); border:1px solid var(--border-med);
  font-size:var(--fz-ctl); font-weight:500; line-height:calc(var(--ctl-h) - 2px);
}
.text-input::placeholder{ color:var(--muted); }
.text-input:focus, .select-input:focus{
  outline:none; box-shadow:0 0 0 2px rgba(110,168,254,.25) inset; border-color:rgba(110,168,254,.55);
}
@media (max-width:600px){ .text-input, .select-input{ flex:1 1 200px; width:100%; } }

/* ===== Buttons (compact) ===== */
.btn{
  display:inline-flex; align-items:center; justify-content:center; min-height:var(--ctl-h);
  padding:0 var(--btn-pad-x); border-radius:var(--btn-radius); cursor:pointer;
  font-size:var(--fz-ctl); font-weight:600; letter-spacing:.01em; line-height:1;
  color:#fff; background: linear-gradient(180deg, var(--accent), rgba(110,168,254,0));
  border:1px solid rgba(110,168,254,.55);
  transition: box-shadow .2s ease, transform .05s ease, opacity .2s ease;
}
.btn:hover{ box-shadow:0 0 0 2px rgba(110,168,254,.25) inset; }
.btn:active{ transform: translateY(1px); }
.btn.secondary{
  background: linear-gradient(180deg, var(--accent-2), rgba(114,227,166,0));
  border-color: rgba(114,227,166,.55);
}
.btn.ghost{ background:transparent; border:1px solid var(--border-med); color:var(--text); }

/* Save button */
#saveBtn{
  position:relative; padding-right:36px;
  background:linear-gradient(180deg, var(--accent-2), rgba(114,227,166,0));
  border-color:rgba(114,227,166,.55);
}
#saveBtn::after{
  content:"💾"; position:absolute; right:10px; top:50%; transform:translateY(-50%);
  font-size:12px; opacity:.9; pointer-events:none;
}
#saveBtn:hover{ box-shadow:0 0 0 2px rgba(114,227,166,.25) inset; }
#saveBtn:active{ transform:translateY(1px); }
#saveBtn:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; }

/* ===== Viewer ===== */
.viewer-card .body{ padding:0; }
#glcanvas{
  width:100%; height:56vh; display:block;
  border-radius:0 0 var(--radius) var(--radius); border-top:1px solid var(--border-soft);
  background: radial-gradient(420px 220px at 18% 12%, rgba(110,168,254,.18), transparent 60%), #0a0f1e;
}

/* ===== Output + Reference ===== */
.output-card .body{
  display:grid; grid-template-columns: 1fr 2fr; gap:12px; align-items:start;
}
@media (max-width:900px){ .output-card .body{ grid-template-columns:1fr; } }
#out{
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size:13px; line-height:1.4; white-space: pre-wrap; overflow-y:auto; max-height:240px;
  padding:10px 12px; background: rgba(0,0,0,0.7); border-radius: 12px; border:1px solid var(--border-soft);
}

/* ===== Mini Reference Dock ===== */
.ref-dock{
  grid-column:2/3; margin-top:10px; border:1px solid var(--smart-border);
  border-radius:12px; overflow:hidden; background: rgba(255,255,255,0.02);
}
.ref-head{
  display:flex; gap:10px; align-items:center; padding:10px 12px; cursor:pointer; user-select:none;
  background: rgba(255,255,255,0.03);
}
.ref-title{ font-weight:800; font-size:12px; letter-spacing:.08em; text-transform:uppercase; color:var(--muted); }
.ref-body{ padding:12px; display:grid; gap:8px; font-size:13px; }
.ref-dock.min .ref-body{ display:none; }
.ref-badge{
  font:700 11px/1 Inter,system-ui,sans-serif; letter-spacing:.06em; text-transform:uppercase;
  color:white; border-radius:999px; padding:2px 8px; display:inline-block;
}
.badge-syntax{ background:#8b5cf6cc; }
.badge-concept{ background:#3b82f6cc; }
.badge-action{ background:#10b981cc; }
.badge-warning{ background:#f59e0bcc; }







/* ===== Layered editor (cursor aligned, drift-free) ===== */
.codewrap{
  position:relative; border-radius:12px; overflow:hidden;
  border:1px solid var(--border-strong);
  background:linear-gradient(180deg, #0f1421 0%, #0e1522 100%);
  min-height:50vh; scrollbar-gutter: stable both-edges;
}

/* Shared text metrics */
.codewrap pre.highlighter,
.codewrap textarea{
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size:14px; line-height:22px; letter-spacing:0; word-spacing:0; tab-size:2;
  font-weight:400; font-variant-ligatures:none; font-kerning:none;
  font-feature-settings:"liga" 0,"calt" 0; font-synthesis-weight:none; font-synthesis-style:none;
  -webkit-font-smoothing:antialiased; text-rendering:optimizeSpeed;
  padding:16px; margin:0; min-height:50vh;
  white-space:pre; /* toggled to pre-wrap when .wrap-on is present */
}

/* Back layer (visible) */
.codewrap pre.highlighter{
  position:absolute; top:0; left:0; z-index:0;
  color:#cbd5e1; pointer-events:none; user-select:none; overflow:visible;
}

/* Textarea draws caret/selection; text transparent so highlight shows */
.codewrap textarea{
  position:absolute; inset:0; z-index:1; width:100%; height:100%;
  background:transparent; color:transparent; -webkit-text-fill-color:transparent;
  caret-color:var(--accent); border:none; outline:none; resize:none; overflow:auto;
}
.codewrap textarea::selection{ background: rgba(110,168,254,.28); }

/* Wrapping parity */
.wrap-on .codewrap pre.highlighter,
.wrap-on .codewrap textarea{ white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; }

/* Tokens */
.tok-kw{   color:var(--green);  font-weight:400 !important; }
.tok-var{  color:var(--blue);   font-weight:400 !important; }
.tok-rule{ color:var(--orange); font-weight:400 !important; }
.tok-num{  color:#ff6b6b;       font-weight:400 !important; }
.tok-op{   color:#e2e8f0;       font-weight:400 !important; }
.tok-paren, .tok-brack{ color:#e7f0ff; }
.highlighter span{ font-weight:inherit; letter-spacing:inherit; font-style:inherit; }
.err-squiggle{
  background-image: linear-gradient(to right, transparent 0 1px, #ff7676 1px 2px, transparent 2px 3px);
  background-size: 6px 2px; background-repeat: repeat-x; background-position: 0 100%;
}
.ctx{ padding:1px 2px; border-radius:6px; }

/* Scrollbars (WebKit) */
.codewrap textarea::-webkit-scrollbar,
.codewrap pre.highlighter::-webkit-scrollbar,
#out::-webkit-scrollbar{ width:10px; height:10px; }
.codewrap textarea::-webkit-scrollbar-thumb,
.codewrap pre.highlighter::-webkit-scrollbar-thumb,
#out::-webkit-scrollbar-thumb{ background:rgba(154,164,178,.35); border-radius:999px; }

/* ===== Hit overlay (hover layer) ===== */
#se-hit{ position:absolute; inset:0; z-index:2; pointer-events:none; }
#se-hit-pre{
  position:absolute; inset:0; margin:0; padding:16px;
  white-space:pre; overflow:visible; color:transparent; user-select:none;
}
.wrap-on #se-hit-pre{ white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; }
#se-hit-pre span{ pointer-events:auto; }

/* ===== Tooltip (fixed to cursor → no scroll math drift) ===== */
#se-tooltip{
  position:fixed; z-index:4; display:none; pointer-events:none;
  background:var(--smart-bg); color:var(--text);
  border:1px solid var(--smart-border); border-radius:8px;
  padding:6px 8px; font:12px/1.3 Inter,system-ui,sans-serif; box-shadow:var(--smart-shadow);
  max-width:42ch;
}
#se-tooltip.is-error {
  border-color: #ff7676;
  box-shadow: 0 8px 24px rgba(255,118,118,.25);
}

</style>


<div class="wrap">
  <!-- ========== INPUT (Wider) ========== -->
  <section class="card input-card">
    <header class="">
      <h2>Grammar Input</h2>
      <div class="toolbar">
        <span id="status" aria-live="polite">⚠ 7 issues · Start: Cylinder · Reachable: 3</span>
        <!-- Use unique ids (avoid duplicate “nameChooser”) -->
        <input id="nameId" class="text-input" list="nameChooserList" placeholder="unique_name_identifier" aria-label="Type or choose identifier">
        <datalist id="nameChooserList"></datalist>
        <select id="nameChooser" class="select-input" aria-label="Choose saved identifier"><option value="" disabled="">Choose saved…</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-202-20250829-100444">cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-202-20250829-100444</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-202">cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-202</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-20250829-075820">cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537-20250829-075820</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537">cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071537</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071235">cylinder_fan-20250828-155016-20250828-160841-20250828-162236-20250829-071235</option><option value="cylinder-prototype-20250829-030013-20250829-042129-20250829-065515">cylinder-prototype-20250829-030013-20250829-042129-20250829-065515</option><option value="cylinder-prototype-20250829-030013-20250829-042129">cylinder-prototype-20250829-030013-20250829-042129</option><option value="cylinder-prototype-20250829-030013">cylinder-prototype-20250829-030013</option><option value="cylinder-prototype">cylinder-prototype</option><option value="cylinder_fan-20250828-155016-20250828-160841-20250828-162236">cylinder_fan-20250828-155016-20250828-160841-20250828-162236</option><option value="cylinder_fan-20250828-155016-20250828-160841">cylinder_fan-20250828-155016-20250828-160841</option><option value="cylinder_fan-20250828-155016">cylinder_fan-20250828-155016</option><option value="cylinder_fan-20250828-154836">cylinder_fan-20250828-154836</option><option value="cylinder_fan">cylinder_fan</option><option value="hollow_cylinder-script-20250828-143941">hollow_cylinder-script-20250828-143941</option><option value="brick_wall">brick_wall</option><option value="hollow_cylinder-script">hollow_cylinder-script</option><option value="hollow_cylinder-20250827-152748">hollow_cylinder-20250827-152748</option><option value="helix_wedge_around_cylinder">helix_wedge_around_cylinder</option><option value="ds_helix_cube_wedge-20250826-122658">ds_helix_cube_wedge-20250826-122658</option><option value="ds_helix_cube_wedge">ds_helix_cube_wedge</option><option value="hollow_cylinder">hollow_cylinder</option><option value="ds_rotated_cube_wedge">ds_rotated_cube_wedge</option><option value="dy_cube_wedge-20250826-100920">dy_cube_wedge-20250826-100920</option><option value="dsdt_cube_wedge_offset">dsdt_cube_wedge_offset</option><option value="dtdt_cube">dtdt_cube</option><option value="d_pyramid">d_pyramid</option><option value="dy_cube_wedge">dy_cube_wedge</option><option value="cylinder">cylinder</option></select>
        <button id="saveBtn" class="btn_save" title="SaveToJson">SaveToJson</button>
        <button id="wrapBtn" class="btn ghost" title="Toggle word wrap">⤶ Wrap: Off</button>
        <button id="go" class="btn">Run Grammar</button>
        <button id="clr" class="btn secondary">Clear</button>
        <!-- ===== Add to your toolbar ===== -->
        <button id="openJsonBtn" class="btn ghost">Open JSON</button>
        <button id="exportJsonBtn" class="btn secondary">Export JSON</button>
      </div>
    </header>
    <div class="body">
<div class="codewrap" id="codewrap" data-se-init="1">
  <pre id="hl" class="highlighter" style="white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 14px; font-weight: 400; font-style: normal; line-height: 22px; letter-spacing: normal; tab-size: 2; text-rendering: optimizespeed; -webkit-font-smoothing: antialiased; font-variant-ligatures: none; font-kerning: none; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; font-synthesis-weight: none; font-synthesis-style: none; padding: 16px; border-width: 0px; box-sizing: border-box; overflow-wrap: normal; word-break: normal; width: 693px; height: 464px; top: -200px; left: 0px;"><span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="0" data-s="0" data-e="1">X</span> <span class="tok-op" data-type="op" data-i="2" data-s="2" data-e="4">-&gt;</span>  <span class="tok-kw" data-type="kw" data-i="4" data-s="6" data-e="7">A</span> <span class="tok-paren" data-type="par" data-i="6" data-s="8" data-e="9">(</span> <span class="tok-num" data-type="num" data-i="8" data-s="10" data-e="12">90</span> <span class="tok-num" data-type="num" data-i="10" data-s="13" data-e="14">2</span> <span class="tok-paren" data-type="par" data-i="12" data-s="15" data-e="16">)</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="14" data-s="17" data-e="21">Main</span>

<span class="tok-rule err-squiggle se-rule-def se-unreach" data-type="id" data-i="16" data-s="23" data-e="27" data-err="Unexpected newline here">Main</span> <span class="tok-op" data-type="op" data-i="18" data-s="28" data-e="30">-&gt;</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="20" data-s="31" data-e="37">Blade1</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="22" data-s="38" data-e="44">Blade2</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="24" data-s="45" data-e="51">Blade3</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="26" data-s="52" data-e="58">Blade4</span>
 <span class="tok-brack" data-type="br" data-i="28" data-s="60" data-e="61">[</span> 
<span class="tok-kw" data-type="kw" data-i="30" data-s="63" data-e="64">T</span> <span class="tok-paren" data-type="par" data-i="32" data-s="65" data-e="66">(</span> <span class="tok-num" data-type="num" data-i="34" data-s="67" data-e="68">0</span> <span class="tok-num" data-type="num" data-i="36" data-s="69" data-e="72">0.2</span> <span class="tok-num" data-type="num" data-i="38" data-s="73" data-e="76">0.2</span> <span class="tok-paren" data-type="par" data-i="40" data-s="77" data-e="78">)</span> <span class="tok-kw" data-type="kw" data-i="42" data-s="79" data-e="80">S</span> <span class="tok-paren" data-type="par" data-i="44" data-s="81" data-e="82">(</span> <span class="tok-num" data-type="num" data-i="46" data-s="83" data-e="86">0.6</span> <span class="tok-num" data-type="num" data-i="48" data-s="87" data-e="91">0.25</span> <span class="tok-num" data-type="num" data-i="50" data-s="92" data-e="96">0.25</span> <span class="tok-paren" data-type="par" data-i="52" data-s="97" data-e="98">)</span> <span class="tok-kw" data-type="kw" data-i="54" data-s="99" data-e="100">A</span> <span class="tok-paren" data-type="par" data-i="56" data-s="101" data-e="102">(</span> <span class="tok-num" data-type="num" data-i="58" data-s="103" data-e="105">90</span> <span class="tok-num" data-type="num" data-i="60" data-s="106" data-e="107">2</span> <span class="tok-paren" data-type="par" data-i="62" data-s="108" data-e="109">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="64" data-s="110" data-e="118">Cylinder</span>
 <span class="tok-brack" data-type="br" data-i="66" data-s="120" data-e="121">]</span>

<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="68" data-s="123" data-e="129">Blade1</span> <span class="tok-num" data-type="num" data-i="70" data-s="130" data-e="132">20</span> <span class="tok-op" data-type="op" data-i="72" data-s="133" data-e="135">-&gt;</span>
  <span class="tok-kw" data-type="kw" data-i="74" data-s="138" data-e="139">A</span> <span class="tok-paren" data-type="par" data-i="76" data-s="140" data-e="141">(</span> <span class="tok-num" data-type="num" data-i="78" data-s="142" data-e="144">18</span> <span class="tok-num" data-type="num" data-i="80" data-s="145" data-e="146">0</span> <span class="tok-paren" data-type="par" data-i="82" data-s="147" data-e="148">)</span>  <span class="tok-brack" data-type="br" data-i="84" data-s="150" data-e="151">[</span>
 <span class="tok-kw" data-type="kw" data-i="86" data-s="153" data-e="154">T</span> <span class="tok-paren" data-type="par" data-i="88" data-s="155" data-e="156">(</span> <span class="tok-num" data-type="num" data-i="90" data-s="157" data-e="158">0</span> <span class="tok-num" data-type="num" data-i="92" data-s="159" data-e="160">1</span> <span class="tok-num" data-type="num" data-i="94" data-s="161" data-e="162">0</span> <span class="tok-paren" data-type="par" data-i="96" data-s="163" data-e="164">)</span> <span class="tok-kw" data-type="kw" data-i="98" data-s="165" data-e="166">S</span> <span class="tok-paren" data-type="par" data-i="100" data-s="167" data-e="168">(</span> <span class="tok-num" data-type="num" data-i="102" data-s="169" data-e="170">5</span> <span class="tok-num" data-type="num" data-i="104" data-s="171" data-e="174">0.5</span> <span class="tok-num" data-type="num" data-i="106" data-s="175" data-e="179">0.01</span> <span class="tok-paren" data-type="par" data-i="108" data-s="180" data-e="181">)</span> <span class="tok-kw" data-type="kw" data-i="110" data-s="182" data-e="183">I</span> <span class="tok-paren" data-type="par" data-i="112" data-s="184" data-e="185">(</span> <span class="tok-var" data-type="id" data-i="114" data-s="186" data-e="190">Cube</span> <span class="tok-var" data-type="id" data-i="116" data-s="191" data-e="202">carbonFiber</span> <span class="tok-num" data-type="num" data-i="118" data-s="203" data-e="204">0</span> <span class="tok-num" data-type="num" data-i="120" data-s="205" data-e="206">1</span> <span class="tok-paren" data-type="par" data-i="122" data-s="207" data-e="208">)</span>
 <span class="tok-brack" data-type="br" data-i="124" data-s="210" data-e="211">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="126" data-s="212" data-e="218">Blade2</span> <span class="tok-num" data-type="num" data-i="128" data-s="219" data-e="221">20</span> <span class="tok-op" data-type="op" data-i="130" data-s="222" data-e="224">-&gt;</span> 
 <span class="tok-kw" data-type="kw" data-i="132" data-s="227" data-e="228">A</span> <span class="tok-paren" data-type="par" data-i="134" data-s="229" data-e="230">(</span> <span class="tok-num" data-type="num" data-i="136" data-s="231" data-e="233">18</span> <span class="tok-num" data-type="num" data-i="138" data-s="234" data-e="235">0</span> <span class="tok-paren" data-type="par" data-i="140" data-s="236" data-e="237">)</span>  
<span class="tok-brack" data-type="br" data-i="142" data-s="240" data-e="241">[</span> 
 <span class="tok-kw" data-type="kw" data-i="144" data-s="244" data-e="245">T</span> <span class="tok-paren" data-type="par" data-i="146" data-s="246" data-e="247">(</span> <span class="tok-num" data-type="num" data-i="148" data-s="248" data-e="249">0</span> <span class="tok-num" data-type="num" data-i="150" data-s="250" data-e="254">1.35</span> <span class="tok-num" data-type="num" data-i="152" data-s="255" data-e="258">0.1</span> <span class="tok-paren" data-type="par" data-i="154" data-s="259" data-e="260">)</span> <span class="tok-kw" data-type="kw" data-i="156" data-s="261" data-e="262">A</span> <span class="tok-paren" data-type="par" data-i="158" data-s="263" data-e="264">(</span> <span class="tok-num" data-type="num" data-i="160" data-s="265" data-e="267">15</span> <span class="tok-num" data-type="num" data-i="162" data-s="268" data-e="269">0</span> <span class="tok-paren" data-type="par" data-i="164" data-s="270" data-e="271">)</span> <span class="tok-kw" data-type="kw" data-i="166" data-s="272" data-e="273">S</span> <span class="tok-paren" data-type="par" data-i="168" data-s="274" data-e="275">(</span> <span class="tok-num" data-type="num" data-i="170" data-s="276" data-e="277">5</span> <span class="tok-num" data-type="num" data-i="172" data-s="278" data-e="282">0.25</span> <span class="tok-num" data-type="num" data-i="174" data-s="283" data-e="286">0.1</span> <span class="tok-paren" data-type="par" data-i="176" data-s="287" data-e="288">)</span> <span class="tok-kw" data-type="kw" data-i="178" data-s="289" data-e="290">I</span> <span class="tok-paren" data-type="par" data-i="180" data-s="291" data-e="292">(</span> <span class="tok-var" data-type="id" data-i="182" data-s="293" data-e="297">Cube</span> <span class="tok-var" data-type="id" data-i="184" data-s="298" data-e="314">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="186" data-s="315" data-e="316">0</span> <span class="tok-num" data-type="num" data-i="188" data-s="317" data-e="318">1</span> <span class="tok-paren" data-type="par" data-i="190" data-s="319" data-e="320">)</span>
<span class="tok-brack" data-type="br" data-i="192" data-s="321" data-e="322">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="194" data-s="323" data-e="329">Blade3</span> <span class="tok-num" data-type="num" data-i="196" data-s="330" data-e="332">20</span> <span class="tok-op" data-type="op" data-i="198" data-s="333" data-e="335">-&gt;</span> 
 <span class="tok-kw" data-type="kw" data-i="200" data-s="338" data-e="339">A</span> <span class="tok-paren" data-type="par" data-i="202" data-s="340" data-e="341">(</span> <span class="tok-num" data-type="num" data-i="204" data-s="342" data-e="344">18</span> <span class="tok-num" data-type="num" data-i="206" data-s="345" data-e="346">0</span> <span class="tok-paren" data-type="par" data-i="208" data-s="347" data-e="348">)</span> 
 <span class="tok-brack" data-type="br" data-i="210" data-s="351" data-e="352">[</span>
 <span class="tok-kw" data-type="kw" data-i="212" data-s="354" data-e="355">T</span> <span class="tok-paren" data-type="par" data-i="214" data-s="356" data-e="357">(</span> <span class="tok-num" data-type="num" data-i="216" data-s="358" data-e="359">0</span> <span class="tok-num" data-type="num" data-i="218" data-s="360" data-e="364">1.65</span> <span class="tok-num" data-type="num" data-i="220" data-s="365" data-e="368">0.3</span> <span class="tok-paren" data-type="par" data-i="222" data-s="369" data-e="370">)</span> <span class="tok-kw" data-type="kw" data-i="224" data-s="371" data-e="372">A</span> <span class="tok-paren" data-type="par" data-i="226" data-s="373" data-e="374">(</span> <span class="tok-num" data-type="num" data-i="228" data-s="375" data-e="377">45</span> <span class="tok-num" data-type="num" data-i="230" data-s="378" data-e="379">0</span> <span class="tok-paren" data-type="par" data-i="232" data-s="380" data-e="381">)</span> <span class="tok-kw" data-type="kw" data-i="234" data-s="382" data-e="383">S</span> <span class="tok-paren" data-type="par" data-i="236" data-s="384" data-e="385">(</span> <span class="tok-num" data-type="num" data-i="238" data-s="386" data-e="387">5</span> <span class="tok-num" data-type="num" data-i="240" data-s="388" data-e="392">0.25</span> <span class="tok-num" data-type="num" data-i="242" data-s="393" data-e="396">0.1</span> <span class="tok-paren" data-type="par" data-i="244" data-s="397" data-e="398">)</span> <span class="tok-kw" data-type="kw" data-i="246" data-s="399" data-e="400">I</span> <span class="tok-paren" data-type="par" data-i="248" data-s="401" data-e="402">(</span> <span class="tok-var" data-type="id" data-i="250" data-s="403" data-e="407">Cube</span> <span class="tok-var" data-type="id" data-i="252" data-s="408" data-e="424">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="254" data-s="425" data-e="426">0</span> <span class="tok-num" data-type="num" data-i="256" data-s="427" data-e="428">1</span> <span class="tok-paren" data-type="par" data-i="258" data-s="429" data-e="430">)</span>
 <span class="tok-brack" data-type="br" data-i="260" data-s="432" data-e="433">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="262" data-s="434" data-e="440">Blade4</span> <span class="tok-num" data-type="num" data-i="264" data-s="441" data-e="443">20</span> <span class="tok-op" data-type="op" data-i="266" data-s="444" data-e="446">-&gt;</span>
  <span class="tok-kw" data-type="kw" data-i="268" data-s="449" data-e="450">A</span> <span class="tok-paren" data-type="par" data-i="270" data-s="451" data-e="452">(</span> <span class="tok-num" data-type="num" data-i="272" data-s="453" data-e="455">18</span> <span class="tok-num" data-type="num" data-i="274" data-s="456" data-e="457">0</span> <span class="tok-paren" data-type="par" data-i="276" data-s="458" data-e="459">)</span> 
 <span class="tok-brack" data-type="br" data-i="278" data-s="462" data-e="463">[</span>
 <span class="tok-kw" data-type="kw" data-i="280" data-s="465" data-e="466">T</span> <span class="tok-paren" data-type="par" data-i="282" data-s="467" data-e="468">(</span> <span class="tok-num" data-type="num" data-i="284" data-s="469" data-e="470">0</span> <span class="tok-num" data-type="num" data-i="286" data-s="471" data-e="475">1.55</span> <span class="tok-num" data-type="num" data-i="288" data-s="476" data-e="477">1</span> <span class="tok-paren" data-type="par" data-i="290" data-s="478" data-e="479">)</span> <span class="tok-kw" data-type="kw" data-i="292" data-s="480" data-e="481">A</span> <span class="tok-paren" data-type="par" data-i="294" data-s="482" data-e="483">(</span> <span class="tok-num" data-type="num" data-i="296" data-s="484" data-e="486">85</span> <span class="tok-num" data-type="num" data-i="298" data-s="487" data-e="488">0</span> <span class="tok-paren" data-type="par" data-i="300" data-s="489" data-e="490">)</span> <span class="tok-kw" data-type="kw" data-i="302" data-s="491" data-e="492">S</span> <span class="tok-paren" data-type="par" data-i="304" data-s="493" data-e="494">(</span> <span class="tok-num" data-type="num" data-i="306" data-s="495" data-e="496">5</span> <span class="tok-num" data-type="num" data-i="308" data-s="497" data-e="501">0.25</span> <span class="tok-num" data-type="num" data-i="310" data-s="502" data-e="505">0.1</span> <span class="tok-paren" data-type="par" data-i="312" data-s="506" data-e="507">)</span> <span class="tok-kw" data-type="kw" data-i="314" data-s="508" data-e="509">I</span> <span class="tok-paren" data-type="par" data-i="316" data-s="510" data-e="511">(</span> <span class="tok-var" data-type="id" data-i="318" data-s="512" data-e="516">Cube</span> <span class="tok-var" data-type="id" data-i="320" data-s="517" data-e="533">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="322" data-s="534" data-e="535">0</span> <span class="tok-num" data-type="num" data-i="324" data-s="536" data-e="537">1</span> <span class="tok-paren" data-type="par" data-i="326" data-s="538" data-e="539">)</span>
 <span class="tok-brack" data-type="br" data-i="328" data-s="541" data-e="542">]</span>

<span class="tok-rule se-rule-def se-reach se-active" data-type="id" data-i="330" data-s="544" data-e="552">Cylinder</span> <span class="tok-op" data-type="op" data-i="332" data-s="553" data-e="555">-&gt;</span>
 <span class="tok-kw" data-type="kw" data-i="334" data-s="557" data-e="558">T</span> <span class="tok-paren" data-type="par" data-i="336" data-s="559" data-e="560">(</span> <span class="tok-num" data-type="num" data-i="338" data-s="561" data-e="562">0</span> <span class="tok-num" data-type="num" data-i="340" data-s="563" data-e="564">0</span> <span class="tok-num" data-type="num" data-i="342" data-s="565" data-e="566">2</span> <span class="tok-paren" data-type="par" data-i="344" data-s="567" data-e="568">)</span> <span class="tok-kw" data-type="kw" data-i="346" data-s="569" data-e="570">S</span> <span class="tok-paren" data-type="par" data-i="348" data-s="571" data-e="572">(</span> <span class="tok-num" data-type="num" data-i="350" data-s="573" data-e="574">1</span> <span class="tok-num" data-type="num" data-i="352" data-s="575" data-e="577">10</span> <span class="tok-num" data-type="num" data-i="354" data-s="578" data-e="579">1</span> <span class="tok-paren" data-type="par" data-i="356" data-s="580" data-e="581">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="358" data-s="582" data-e="594">CylinderMain</span>

<span class="tok-rule err-squiggle se-rule-def se-reach" data-type="id" data-i="360" data-s="596" data-e="608" data-err="Unexpected newline here">CylinderMain</span> <span class="tok-num" data-type="num" data-i="362" data-s="609" data-e="611">20</span> <span class="tok-op" data-type="op" data-i="364" data-s="612" data-e="614">-&gt;</span>
 <span class="tok-kw" data-type="kw" data-i="366" data-s="616" data-e="617">A</span> <span class="tok-paren" data-type="par" data-i="368" data-s="618" data-e="619">(</span> <span class="tok-num" data-type="num" data-i="370" data-s="620" data-e="623">360</span><span class="tok-op" data-type="sym" data-i="371" data-s="623" data-e="624">/</span><span class="tok-num" data-type="num" data-i="372" data-s="624" data-e="628">20.0</span> <span class="tok-num" data-type="num" data-i="374" data-s="629" data-e="630">1</span> <span class="tok-paren" data-type="par" data-i="376" data-s="631" data-e="632">)</span> <span class="tok-kw" data-type="kw" data-i="378" data-s="633" data-e="634">T</span> <span class="tok-paren" data-type="par" data-i="380" data-s="635" data-e="636">(</span> <span class="tok-num" data-type="num" data-i="382" data-s="637" data-e="640">0.9</span> <span class="tok-num" data-type="num" data-i="384" data-s="641" data-e="642">0</span> <span class="tok-num" data-type="num" data-i="386" data-s="643" data-e="644">0</span> <span class="tok-paren" data-type="par" data-i="388" data-s="645" data-e="646">)</span> <span class="tok-var" data-type="id" data-i="390" data-s="647" data-e="649">DS</span> <span class="tok-paren" data-type="par" data-i="392" data-s="650" data-e="651">(</span> <span class="tok-num" data-type="num" data-i="394" data-s="652" data-e="653">1</span> <span class="tok-num" data-type="num" data-i="396" data-s="654" data-e="657">0.8</span> <span class="tok-num" data-type="num" data-i="398" data-s="658" data-e="659">1</span> <span class="tok-paren" data-type="par" data-i="400" data-s="660" data-e="661">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="402" data-s="662" data-e="667">Wedge</span>

<span class="tok-rule err-squiggle se-rule-def se-reach" data-type="id" data-i="404" data-s="669" data-e="674" data-err="Unexpected newline here">Wedge</span> <span class="tok-op" data-type="op" data-i="406" data-s="675" data-e="677">-&gt;</span> <span class="tok-brack" data-type="br" data-i="408" data-s="678" data-e="679">[</span> 
<span class="tok-kw" data-type="kw" data-i="410" data-s="681" data-e="682">A</span> <span class="tok-paren" data-type="par" data-i="412" data-s="683" data-e="684">(</span> <span class="tok-num" data-type="num" data-i="414" data-s="685" data-e="688">180</span><span class="tok-op" data-type="sym" data-i="415" data-s="688" data-e="689">+</span><span class="tok-num" data-type="num" data-i="416" data-s="689" data-e="691">10</span> <span class="tok-num" data-type="num" data-i="418" data-s="692" data-e="693">1</span> <span class="tok-paren" data-type="par" data-i="420" data-s="694" data-e="695">)</span> 
<span class="tok-kw" data-type="kw" data-i="422" data-s="697" data-e="698">A</span> <span class="tok-paren" data-type="par" data-i="424" data-s="699" data-e="700">(</span> <span class="tok-num" data-type="num" data-i="426" data-s="701" data-e="704">270</span> <span class="tok-num" data-type="num" data-i="428" data-s="705" data-e="706">2</span> <span class="tok-paren" data-type="par" data-i="430" data-s="707" data-e="708">)</span> 
<span class="tok-kw" data-type="kw" data-i="432" data-s="710" data-e="711">I</span> <span class="tok-paren" data-type="par" data-i="434" data-s="712" data-e="713">(</span> <span class="tok-var" data-type="id" data-i="436" data-s="714" data-e="718">Cube</span> <span class="tok-var" data-type="id" data-i="438" data-s="719" data-e="726">rawIron</span> <span class="tok-num" data-type="num" data-i="440" data-s="727" data-e="728">0</span> <span class="tok-num" data-type="num" data-i="442" data-s="729" data-e="733">1.25</span> <span class="tok-paren" data-type="par" data-i="444" data-s="734" data-e="735">)</span> 
<span class="tok-brack" data-type="br" data-i="446" data-s="737" data-e="738">]</span>
</pre>
  <textarea id="src" wrap="off" spellcheck="false" placeholder="Enter Visual Grammar..." style="white-space: pre;"></textarea>

  <!-- Hover hit overlay -->
  <div id="se-hit" aria-hidden="true" style="pointer-events: none;">
    <pre id="se-hit-pre" class="highlighter" style="white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, &quot;Liberation Mono&quot;, monospace; font-size: 14px; font-weight: 400; font-style: normal; line-height: 22px; letter-spacing: normal; tab-size: 2; text-rendering: optimizespeed; -webkit-font-smoothing: antialiased; font-variant-ligatures: none; font-kerning: none; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; font-synthesis-weight: none; font-synthesis-style: none; padding: 16px; border-width: 0px; box-sizing: border-box; overflow-wrap: normal; word-break: normal; width: 693px; height: 464px; top: -200px; left: 0px;"><span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="0" data-s="0" data-e="1">X</span> <span class="tok-op" data-type="op" data-i="2" data-s="2" data-e="4">-&gt;</span>  <span class="tok-kw" data-type="kw" data-i="4" data-s="6" data-e="7">A</span> <span class="tok-paren" data-type="par" data-i="6" data-s="8" data-e="9">(</span> <span class="tok-num" data-type="num" data-i="8" data-s="10" data-e="12">90</span> <span class="tok-num" data-type="num" data-i="10" data-s="13" data-e="14">2</span> <span class="tok-paren" data-type="par" data-i="12" data-s="15" data-e="16">)</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="14" data-s="17" data-e="21">Main</span>

<span class="tok-rule err-squiggle se-rule-def se-unreach" data-type="id" data-i="16" data-s="23" data-e="27" data-err="Unexpected newline here">Main</span> <span class="tok-op" data-type="op" data-i="18" data-s="28" data-e="30">-&gt;</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="20" data-s="31" data-e="37">Blade1</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="22" data-s="38" data-e="44">Blade2</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="24" data-s="45" data-e="51">Blade3</span> <span class="tok-rule se-rule-ref se-unreach" data-type="id" data-i="26" data-s="52" data-e="58">Blade4</span>
 <span class="tok-brack" data-type="br" data-i="28" data-s="60" data-e="61">[</span> 
<span class="tok-kw" data-type="kw" data-i="30" data-s="63" data-e="64">T</span> <span class="tok-paren" data-type="par" data-i="32" data-s="65" data-e="66">(</span> <span class="tok-num" data-type="num" data-i="34" data-s="67" data-e="68">0</span> <span class="tok-num" data-type="num" data-i="36" data-s="69" data-e="72">0.2</span> <span class="tok-num" data-type="num" data-i="38" data-s="73" data-e="76">0.2</span> <span class="tok-paren" data-type="par" data-i="40" data-s="77" data-e="78">)</span> <span class="tok-kw" data-type="kw" data-i="42" data-s="79" data-e="80">S</span> <span class="tok-paren" data-type="par" data-i="44" data-s="81" data-e="82">(</span> <span class="tok-num" data-type="num" data-i="46" data-s="83" data-e="86">0.6</span> <span class="tok-num" data-type="num" data-i="48" data-s="87" data-e="91">0.25</span> <span class="tok-num" data-type="num" data-i="50" data-s="92" data-e="96">0.25</span> <span class="tok-paren" data-type="par" data-i="52" data-s="97" data-e="98">)</span> <span class="tok-kw" data-type="kw" data-i="54" data-s="99" data-e="100">A</span> <span class="tok-paren" data-type="par" data-i="56" data-s="101" data-e="102">(</span> <span class="tok-num" data-type="num" data-i="58" data-s="103" data-e="105">90</span> <span class="tok-num" data-type="num" data-i="60" data-s="106" data-e="107">2</span> <span class="tok-paren" data-type="par" data-i="62" data-s="108" data-e="109">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="64" data-s="110" data-e="118">Cylinder</span>
 <span class="tok-brack" data-type="br" data-i="66" data-s="120" data-e="121">]</span>

<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="68" data-s="123" data-e="129">Blade1</span> <span class="tok-num" data-type="num" data-i="70" data-s="130" data-e="132">20</span> <span class="tok-op" data-type="op" data-i="72" data-s="133" data-e="135">-&gt;</span>
  <span class="tok-kw" data-type="kw" data-i="74" data-s="138" data-e="139">A</span> <span class="tok-paren" data-type="par" data-i="76" data-s="140" data-e="141">(</span> <span class="tok-num" data-type="num" data-i="78" data-s="142" data-e="144">18</span> <span class="tok-num" data-type="num" data-i="80" data-s="145" data-e="146">0</span> <span class="tok-paren" data-type="par" data-i="82" data-s="147" data-e="148">)</span>  <span class="tok-brack" data-type="br" data-i="84" data-s="150" data-e="151">[</span>
 <span class="tok-kw" data-type="kw" data-i="86" data-s="153" data-e="154">T</span> <span class="tok-paren" data-type="par" data-i="88" data-s="155" data-e="156">(</span> <span class="tok-num" data-type="num" data-i="90" data-s="157" data-e="158">0</span> <span class="tok-num" data-type="num" data-i="92" data-s="159" data-e="160">1</span> <span class="tok-num" data-type="num" data-i="94" data-s="161" data-e="162">0</span> <span class="tok-paren" data-type="par" data-i="96" data-s="163" data-e="164">)</span> <span class="tok-kw" data-type="kw" data-i="98" data-s="165" data-e="166">S</span> <span class="tok-paren" data-type="par" data-i="100" data-s="167" data-e="168">(</span> <span class="tok-num" data-type="num" data-i="102" data-s="169" data-e="170">5</span> <span class="tok-num" data-type="num" data-i="104" data-s="171" data-e="174">0.5</span> <span class="tok-num" data-type="num" data-i="106" data-s="175" data-e="179">0.01</span> <span class="tok-paren" data-type="par" data-i="108" data-s="180" data-e="181">)</span> <span class="tok-kw" data-type="kw" data-i="110" data-s="182" data-e="183">I</span> <span class="tok-paren" data-type="par" data-i="112" data-s="184" data-e="185">(</span> <span class="tok-var" data-type="id" data-i="114" data-s="186" data-e="190">Cube</span> <span class="tok-var" data-type="id" data-i="116" data-s="191" data-e="202">carbonFiber</span> <span class="tok-num" data-type="num" data-i="118" data-s="203" data-e="204">0</span> <span class="tok-num" data-type="num" data-i="120" data-s="205" data-e="206">1</span> <span class="tok-paren" data-type="par" data-i="122" data-s="207" data-e="208">)</span>
 <span class="tok-brack" data-type="br" data-i="124" data-s="210" data-e="211">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="126" data-s="212" data-e="218">Blade2</span> <span class="tok-num" data-type="num" data-i="128" data-s="219" data-e="221">20</span> <span class="tok-op" data-type="op" data-i="130" data-s="222" data-e="224">-&gt;</span> 
 <span class="tok-kw" data-type="kw" data-i="132" data-s="227" data-e="228">A</span> <span class="tok-paren" data-type="par" data-i="134" data-s="229" data-e="230">(</span> <span class="tok-num" data-type="num" data-i="136" data-s="231" data-e="233">18</span> <span class="tok-num" data-type="num" data-i="138" data-s="234" data-e="235">0</span> <span class="tok-paren" data-type="par" data-i="140" data-s="236" data-e="237">)</span>  
<span class="tok-brack" data-type="br" data-i="142" data-s="240" data-e="241">[</span> 
 <span class="tok-kw" data-type="kw" data-i="144" data-s="244" data-e="245">T</span> <span class="tok-paren" data-type="par" data-i="146" data-s="246" data-e="247">(</span> <span class="tok-num" data-type="num" data-i="148" data-s="248" data-e="249">0</span> <span class="tok-num" data-type="num" data-i="150" data-s="250" data-e="254">1.35</span> <span class="tok-num" data-type="num" data-i="152" data-s="255" data-e="258">0.1</span> <span class="tok-paren" data-type="par" data-i="154" data-s="259" data-e="260">)</span> <span class="tok-kw" data-type="kw" data-i="156" data-s="261" data-e="262">A</span> <span class="tok-paren" data-type="par" data-i="158" data-s="263" data-e="264">(</span> <span class="tok-num" data-type="num" data-i="160" data-s="265" data-e="267">15</span> <span class="tok-num" data-type="num" data-i="162" data-s="268" data-e="269">0</span> <span class="tok-paren" data-type="par" data-i="164" data-s="270" data-e="271">)</span> <span class="tok-kw" data-type="kw" data-i="166" data-s="272" data-e="273">S</span> <span class="tok-paren" data-type="par" data-i="168" data-s="274" data-e="275">(</span> <span class="tok-num" data-type="num" data-i="170" data-s="276" data-e="277">5</span> <span class="tok-num" data-type="num" data-i="172" data-s="278" data-e="282">0.25</span> <span class="tok-num" data-type="num" data-i="174" data-s="283" data-e="286">0.1</span> <span class="tok-paren" data-type="par" data-i="176" data-s="287" data-e="288">)</span> <span class="tok-kw" data-type="kw" data-i="178" data-s="289" data-e="290">I</span> <span class="tok-paren" data-type="par" data-i="180" data-s="291" data-e="292">(</span> <span class="tok-var" data-type="id" data-i="182" data-s="293" data-e="297">Cube</span> <span class="tok-var" data-type="id" data-i="184" data-s="298" data-e="314">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="186" data-s="315" data-e="316">0</span> <span class="tok-num" data-type="num" data-i="188" data-s="317" data-e="318">1</span> <span class="tok-paren" data-type="par" data-i="190" data-s="319" data-e="320">)</span>
<span class="tok-brack" data-type="br" data-i="192" data-s="321" data-e="322">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="194" data-s="323" data-e="329">Blade3</span> <span class="tok-num" data-type="num" data-i="196" data-s="330" data-e="332">20</span> <span class="tok-op" data-type="op" data-i="198" data-s="333" data-e="335">-&gt;</span> 
 <span class="tok-kw" data-type="kw" data-i="200" data-s="338" data-e="339">A</span> <span class="tok-paren" data-type="par" data-i="202" data-s="340" data-e="341">(</span> <span class="tok-num" data-type="num" data-i="204" data-s="342" data-e="344">18</span> <span class="tok-num" data-type="num" data-i="206" data-s="345" data-e="346">0</span> <span class="tok-paren" data-type="par" data-i="208" data-s="347" data-e="348">)</span> 
 <span class="tok-brack" data-type="br" data-i="210" data-s="351" data-e="352">[</span>
 <span class="tok-kw" data-type="kw" data-i="212" data-s="354" data-e="355">T</span> <span class="tok-paren" data-type="par" data-i="214" data-s="356" data-e="357">(</span> <span class="tok-num" data-type="num" data-i="216" data-s="358" data-e="359">0</span> <span class="tok-num" data-type="num" data-i="218" data-s="360" data-e="364">1.65</span> <span class="tok-num" data-type="num" data-i="220" data-s="365" data-e="368">0.3</span> <span class="tok-paren" data-type="par" data-i="222" data-s="369" data-e="370">)</span> <span class="tok-kw" data-type="kw" data-i="224" data-s="371" data-e="372">A</span> <span class="tok-paren" data-type="par" data-i="226" data-s="373" data-e="374">(</span> <span class="tok-num" data-type="num" data-i="228" data-s="375" data-e="377">45</span> <span class="tok-num" data-type="num" data-i="230" data-s="378" data-e="379">0</span> <span class="tok-paren" data-type="par" data-i="232" data-s="380" data-e="381">)</span> <span class="tok-kw" data-type="kw" data-i="234" data-s="382" data-e="383">S</span> <span class="tok-paren" data-type="par" data-i="236" data-s="384" data-e="385">(</span> <span class="tok-num" data-type="num" data-i="238" data-s="386" data-e="387">5</span> <span class="tok-num" data-type="num" data-i="240" data-s="388" data-e="392">0.25</span> <span class="tok-num" data-type="num" data-i="242" data-s="393" data-e="396">0.1</span> <span class="tok-paren" data-type="par" data-i="244" data-s="397" data-e="398">)</span> <span class="tok-kw" data-type="kw" data-i="246" data-s="399" data-e="400">I</span> <span class="tok-paren" data-type="par" data-i="248" data-s="401" data-e="402">(</span> <span class="tok-var" data-type="id" data-i="250" data-s="403" data-e="407">Cube</span> <span class="tok-var" data-type="id" data-i="252" data-s="408" data-e="424">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="254" data-s="425" data-e="426">0</span> <span class="tok-num" data-type="num" data-i="256" data-s="427" data-e="428">1</span> <span class="tok-paren" data-type="par" data-i="258" data-s="429" data-e="430">)</span>
 <span class="tok-brack" data-type="br" data-i="260" data-s="432" data-e="433">]</span>
<span class="tok-rule se-rule-def se-unreach" data-type="id" data-i="262" data-s="434" data-e="440">Blade4</span> <span class="tok-num" data-type="num" data-i="264" data-s="441" data-e="443">20</span> <span class="tok-op" data-type="op" data-i="266" data-s="444" data-e="446">-&gt;</span>
  <span class="tok-kw" data-type="kw" data-i="268" data-s="449" data-e="450">A</span> <span class="tok-paren" data-type="par" data-i="270" data-s="451" data-e="452">(</span> <span class="tok-num" data-type="num" data-i="272" data-s="453" data-e="455">18</span> <span class="tok-num" data-type="num" data-i="274" data-s="456" data-e="457">0</span> <span class="tok-paren" data-type="par" data-i="276" data-s="458" data-e="459">)</span> 
 <span class="tok-brack" data-type="br" data-i="278" data-s="462" data-e="463">[</span>
 <span class="tok-kw" data-type="kw" data-i="280" data-s="465" data-e="466">T</span> <span class="tok-paren" data-type="par" data-i="282" data-s="467" data-e="468">(</span> <span class="tok-num" data-type="num" data-i="284" data-s="469" data-e="470">0</span> <span class="tok-num" data-type="num" data-i="286" data-s="471" data-e="475">1.55</span> <span class="tok-num" data-type="num" data-i="288" data-s="476" data-e="477">1</span> <span class="tok-paren" data-type="par" data-i="290" data-s="478" data-e="479">)</span> <span class="tok-kw" data-type="kw" data-i="292" data-s="480" data-e="481">A</span> <span class="tok-paren" data-type="par" data-i="294" data-s="482" data-e="483">(</span> <span class="tok-num" data-type="num" data-i="296" data-s="484" data-e="486">85</span> <span class="tok-num" data-type="num" data-i="298" data-s="487" data-e="488">0</span> <span class="tok-paren" data-type="par" data-i="300" data-s="489" data-e="490">)</span> <span class="tok-kw" data-type="kw" data-i="302" data-s="491" data-e="492">S</span> <span class="tok-paren" data-type="par" data-i="304" data-s="493" data-e="494">(</span> <span class="tok-num" data-type="num" data-i="306" data-s="495" data-e="496">5</span> <span class="tok-num" data-type="num" data-i="308" data-s="497" data-e="501">0.25</span> <span class="tok-num" data-type="num" data-i="310" data-s="502" data-e="505">0.1</span> <span class="tok-paren" data-type="par" data-i="312" data-s="506" data-e="507">)</span> <span class="tok-kw" data-type="kw" data-i="314" data-s="508" data-e="509">I</span> <span class="tok-paren" data-type="par" data-i="316" data-s="510" data-e="511">(</span> <span class="tok-var" data-type="id" data-i="318" data-s="512" data-e="516">Cube</span> <span class="tok-var" data-type="id" data-i="320" data-s="517" data-e="533">polishedTitanium</span> <span class="tok-num" data-type="num" data-i="322" data-s="534" data-e="535">0</span> <span class="tok-num" data-type="num" data-i="324" data-s="536" data-e="537">1</span> <span class="tok-paren" data-type="par" data-i="326" data-s="538" data-e="539">)</span>
 <span class="tok-brack" data-type="br" data-i="328" data-s="541" data-e="542">]</span>

<span class="tok-rule se-rule-def se-reach se-active" data-type="id" data-i="330" data-s="544" data-e="552">Cylinder</span> <span class="tok-op" data-type="op" data-i="332" data-s="553" data-e="555">-&gt;</span>
 <span class="tok-kw" data-type="kw" data-i="334" data-s="557" data-e="558">T</span> <span class="tok-paren" data-type="par" data-i="336" data-s="559" data-e="560">(</span> <span class="tok-num" data-type="num" data-i="338" data-s="561" data-e="562">0</span> <span class="tok-num" data-type="num" data-i="340" data-s="563" data-e="564">0</span> <span class="tok-num" data-type="num" data-i="342" data-s="565" data-e="566">2</span> <span class="tok-paren" data-type="par" data-i="344" data-s="567" data-e="568">)</span> <span class="tok-kw" data-type="kw" data-i="346" data-s="569" data-e="570">S</span> <span class="tok-paren" data-type="par" data-i="348" data-s="571" data-e="572">(</span> <span class="tok-num" data-type="num" data-i="350" data-s="573" data-e="574">1</span> <span class="tok-num" data-type="num" data-i="352" data-s="575" data-e="577">10</span> <span class="tok-num" data-type="num" data-i="354" data-s="578" data-e="579">1</span> <span class="tok-paren" data-type="par" data-i="356" data-s="580" data-e="581">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="358" data-s="582" data-e="594">CylinderMain</span>

<span class="tok-rule err-squiggle se-rule-def se-reach" data-type="id" data-i="360" data-s="596" data-e="608" data-err="Unexpected newline here">CylinderMain</span> <span class="tok-num" data-type="num" data-i="362" data-s="609" data-e="611">20</span> <span class="tok-op" data-type="op" data-i="364" data-s="612" data-e="614">-&gt;</span>
 <span class="tok-kw" data-type="kw" data-i="366" data-s="616" data-e="617">A</span> <span class="tok-paren" data-type="par" data-i="368" data-s="618" data-e="619">(</span> <span class="tok-num" data-type="num" data-i="370" data-s="620" data-e="623">360</span><span class="tok-op" data-type="sym" data-i="371" data-s="623" data-e="624">/</span><span class="tok-num" data-type="num" data-i="372" data-s="624" data-e="628">20.0</span> <span class="tok-num" data-type="num" data-i="374" data-s="629" data-e="630">1</span> <span class="tok-paren" data-type="par" data-i="376" data-s="631" data-e="632">)</span> <span class="tok-kw" data-type="kw" data-i="378" data-s="633" data-e="634">T</span> <span class="tok-paren" data-type="par" data-i="380" data-s="635" data-e="636">(</span> <span class="tok-num" data-type="num" data-i="382" data-s="637" data-e="640">0.9</span> <span class="tok-num" data-type="num" data-i="384" data-s="641" data-e="642">0</span> <span class="tok-num" data-type="num" data-i="386" data-s="643" data-e="644">0</span> <span class="tok-paren" data-type="par" data-i="388" data-s="645" data-e="646">)</span> <span class="tok-var" data-type="id" data-i="390" data-s="647" data-e="649">DS</span> <span class="tok-paren" data-type="par" data-i="392" data-s="650" data-e="651">(</span> <span class="tok-num" data-type="num" data-i="394" data-s="652" data-e="653">1</span> <span class="tok-num" data-type="num" data-i="396" data-s="654" data-e="657">0.8</span> <span class="tok-num" data-type="num" data-i="398" data-s="658" data-e="659">1</span> <span class="tok-paren" data-type="par" data-i="400" data-s="660" data-e="661">)</span> <span class="tok-rule se-rule-ref se-reach" data-type="id" data-i="402" data-s="662" data-e="667">Wedge</span>

<span class="tok-rule err-squiggle se-rule-def se-reach" data-type="id" data-i="404" data-s="669" data-e="674" data-err="Unexpected newline here">Wedge</span> <span class="tok-op" data-type="op" data-i="406" data-s="675" data-e="677">-&gt;</span> <span class="tok-brack" data-type="br" data-i="408" data-s="678" data-e="679">[</span> 
<span class="tok-kw" data-type="kw" data-i="410" data-s="681" data-e="682">A</span> <span class="tok-paren" data-type="par" data-i="412" data-s="683" data-e="684">(</span> <span class="tok-num" data-type="num" data-i="414" data-s="685" data-e="688">180</span><span class="tok-op" data-type="sym" data-i="415" data-s="688" data-e="689">+</span><span class="tok-num" data-type="num" data-i="416" data-s="689" data-e="691">10</span> <span class="tok-num" data-type="num" data-i="418" data-s="692" data-e="693">1</span> <span class="tok-paren" data-type="par" data-i="420" data-s="694" data-e="695">)</span> 
<span class="tok-kw" data-type="kw" data-i="422" data-s="697" data-e="698">A</span> <span class="tok-paren" data-type="par" data-i="424" data-s="699" data-e="700">(</span> <span class="tok-num" data-type="num" data-i="426" data-s="701" data-e="704">270</span> <span class="tok-num" data-type="num" data-i="428" data-s="705" data-e="706">2</span> <span class="tok-paren" data-type="par" data-i="430" data-s="707" data-e="708">)</span> 
<span class="tok-kw" data-type="kw" data-i="432" data-s="710" data-e="711">I</span> <span class="tok-paren" data-type="par" data-i="434" data-s="712" data-e="713">(</span> <span class="tok-var" data-type="id" data-i="436" data-s="714" data-e="718">Cube</span> <span class="tok-var" data-type="id" data-i="438" data-s="719" data-e="726">rawIron</span> <span class="tok-num" data-type="num" data-i="440" data-s="727" data-e="728">0</span> <span class="tok-num" data-type="num" data-i="442" data-s="729" data-e="733">1.25</span> <span class="tok-paren" data-type="par" data-i="444" data-s="734" data-e="735">)</span> 
<span class="tok-brack" data-type="br" data-i="446" data-s="737" data-e="738">]</span>
</pre>
  </div>

  <!-- Tooltip -->
  <div id="se-tooltip" style="display: none; left: 596px; top: 583px;" class="">Identifier: polishedTitanium</div>

</div>
    </div>
  </section>

  <!-- ========== VIEWER ========== -->
  <section class="card viewer-card">
    <header>
      <h2>Scene Viewer</h2>
      <div class="toolbar">
        <button id="orbitToggle" class="btn ghost" title="Play/Pause slow orbit">⏸ Auto Orbit</button>
      </div>
    </header>
    <div class="body">
      <canvas id="glcanvas" width="473" height="518" aria-label="WebGL scene canvas"></canvas>
    </div>
  </section>

  <!-- ========== OUTPUT + Mini Reference Dock ========== -->
  <section class="card output-card">
    <header><h2>Tokens &amp; Scene</h2></header>
    <div class="body">
      <pre id="out">Tutorial: Visual Grammar 101 — Step 0/9 (initialising)
Adding texture roughConcrete.
Adding texture smoothConcrete.
Adding texture crackedAsphalt.
Adding texture redBrickWall.
Adding texture whiteTiles.
Adding texture blueCeramicTile.
Adding texture shinySteel.
Adding texture brushedAluminum.
Adding texture oxidizedCopper.
Adding texture agedBronze.
Adding texture shinyGold.
Adding texture tarnishedSilver.
Adding texture rawIron.
Adding texture polishedTitanium.
Adding texture clearGlass.
Adding texture frostedGlass.
Adding texture tintedGreenGlass.
Adding texture stainedBlueGlass.
Adding texture glossyWhitePlastic.
Adding texture matteBlackPlastic.
Adding texture redABS.
Adding texture bluePVC.
Adding texture translucentPoly.
Adding texture freshGrass.
Adding texture dryGrass.
Adding texture desertSand.
Adding texture muddySoil.
Adding texture grayStone.
Adding texture darkBasalt.
Adding texture whiteMarble.
Adding texture greenMarble.
Adding texture oakPlanks.
Adding texture darkWalnut.
Adding texture pineWood.
Adding texture mahoganyWood.
Adding texture cherryWood.
Adding texture mapleWood.
Adding texture iceBlock.
Adding texture moltenLava.
Adding texture deepWater.
Adding texture snowPowder.
Adding texture fluffyCloud.
Adding texture mossPatch.
Adding texture claySoil.
Adding texture rustyMetal.
Adding texture carbonFiber.
Adding texture circuitBoard.
Adding texture glowingPanel.
Adding texture hazardStripe.
Adding texture steelGrid.
Adding texture chromeSurface.[15:30:19]Renderer initialised.[15:33:33]Parsing grammar and preparing scene…[15:33:33]Tokenising… (708 tokens)
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture carbonFiber.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture polishedTitanium.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.
Found texture rawIron.<div class="console-line console-info"><span class="console-time">[15:33:33]</span><span class="console-msg">Build complete. Scene items: 100</span></div></pre>
      <div class="ref-dock min" id="refDock">
        <div class="ref-head" id="refHead">
          <span class="ref-title">Mini-Reference</span>
          <span class="ref-badge badge-syntax">Syntax</span>
          <span class="ref-badge badge-concept">Concept</span>
          <span class="ref-badge badge-action">Action</span>
          <span class="ref-badge badge-warning">Spacing</span>
          <span style="margin-left:auto; color:var(--muted); font-size:12px;" id="refToggleLabel">Show ▼</span>
        </div>
        <div class="ref-body" id="refBody">
          <div><span class="ref-badge badge-syntax">R</span> <code>R name ( min max )</code> — define a variable range (e.g., <code>R len ( 0.15 0.3 )</code>).</div>
          <div><span class="ref-badge badge-action">T</span> <code>T ( x y z )</code> — translate.</div>
          <div><span class="ref-badge badge-action">S</span> <code>S ( sx sy sz )</code> — scale (uniform or per-axis).</div>
          <div><span class="ref-badge badge-action">A</span> <code>A ( degrees 0 )</code> — rotate by degrees.</div>
          <div><span class="ref-badge badge-action">D</span> <code>D ( sx sy sz )</code> — scale cube in x/y/z (dimensions).</div>
          <div><span class="ref-badge badge-concept">I</span> <code>I ( Cube | CubeX | CubeY … )</code> — instantiate primitive.</div>
          <div><span class="ref-badge badge-syntax">Rules</span> <code>rule_name repeat vars… -&gt; body</code>. Transform stack: <code>[</code> push, <code>]</code> pop, <code>{</code> start, <code>}</code> end.</div>
          <div><span class="ref-badge badge-warning">Spacing</span> Tokens are <strong>space-delimited</strong>. Put spaces around parentheses and brackets:<br> ✅ <code>S ( 1 2 3 )</code> · <code>[ Y ]</code> &nbsp; / &nbsp; ❌ <code>S(1 2 3)</code> · <code>[Y]</code></div>
        </div>
      </div>
    </div>
  </section>
</div>
  </div>
 
  
            <script>       
            /* Simple JSON store (replace with your app’s real data model) */
let savedData = {};

/* Save to JSON (from textarea + nameId) */
document.getElementById("saveBtn").addEventListener("click", () => {
  const name = document.getElementById("nameId").value.trim();
  const src = document.getElementById("src").value;
  if (!name) {
    alert("Please enter a unique identifier before saving.");
    return;
  }
  savedData[name] = src;
  document.getElementById("status").textContent = `Saved as "${name}".`;
});

/* Export JSON (download file) */
document.getElementById("exportJsonBtn").addEventListener("click", () => {
  const blob = new Blob([JSON.stringify(savedData, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "saved_grammar.json";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

/* Open JSON (upload + load) */
document.getElementById("openJsonBtn").addEventListener("click", () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        savedData = JSON.parse(evt.target.result);
        document.getElementById("status").textContent = `Loaded ${Object.keys(savedData).length} entries.`;

        // populate dropdown
        const chooser = document.getElementById("nameChooser");
        chooser.innerHTML = '<option value="" disabled selected>Choose saved…</option>';
        Object.keys(savedData).forEach(key => {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = key;
          chooser.appendChild(opt);
        });

      } catch (err) {
        alert("Invalid JSON file.");
      }
    };
    reader.readAsText(file);
  };
  input.click();
});

/* Load from dropdown */
document.getElementById("nameChooser").addEventListener("change", e => {
  const key = e.target.value;
  if (savedData[key]) {
    document.getElementById("src").value = savedData[key];
    document.getElementById("status").textContent = `Loaded "${key}".`;
  }
});
            </script>    
    
            <script>       
            // Math and Grammar Space-delimited math + grammar (refactored + execute pipeline)  
"use strict";
(function(){
  const ta      = document.getElementById('src');
  const hl      = document.getElementById('hl');
  const wrapBtn = document.getElementById('wrapBtn');
  const hitPre  = document.getElementById('se-hit-pre'); // optional hover layer

  if (!ta || !hl) return;

  // ----------------------------
  // 1) Metrics cloning (critical)
  // ----------------------------
  const METRIC_PROPS = [
    'font-family','font-size','font-weight','font-style','line-height','letter-spacing',
    'tab-size','text-rendering','-webkit-font-smoothing','font-variant-ligatures',
    'font-kerning','font-feature-settings','font-synthesis-weight','font-synthesis-style',
    'padding-top','padding-right','padding-bottom','padding-left',
    'border-top-width','border-right-width','border-bottom-width','border-left-width',
    'box-sizing','white-space','overflow-wrap','word-break'
  ];

  function cloneMetrics() {
    const cs = getComputedStyle(ta);

    // copy text metrics exactly to the back layer
    METRIC_PROPS.forEach(p => hl.style.setProperty(p, cs.getPropertyValue(p)));

    // IMPORTANT: size overlays to full content (not just viewport)
    hl.style.width  = ta.scrollWidth  + 'px';
    hl.style.height = ta.scrollHeight + 'px';

    // Mirror metrics to the hover hit layer if present
    if (hitPre) {
      METRIC_PROPS.forEach(p => hitPre.style.setProperty(p, cs.getPropertyValue(p)));
      hitPre.style.width  = ta.scrollWidth  + 'px';
      hitPre.style.height = ta.scrollHeight + 'px';
    }
  }

  // --------------------------------
  // 2) Token paint (very lightweight)
  // --------------------------------
  function escapeHTML(s){
    return s.replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));
  }

  function highlight(src){
    // basic demo lexer; extend as needed
    let s = escapeHTML(src);
    s = s.replace(/\b(\d+(?:\.\d+)?)\b/g, '<span class="tok-num">$1</span>');           // numbers
    s = s.replace(/\b(R\*?|R|T|S|A|D|I)\b/g, '<span class="tok-kw">$1</span>');          // keywords
    s = s.replace(/\b([A-Z][A-Za-z0-9_]*)\b/g, '<span class="tok-var">$1</span>');       // identifiers/rules (demo)
    s = s.replace(/([\[\]\(\)])/g, '<span class="tok-paren">$1</span>');                 // parens/brackets
    return s;
  }

  // -----------------------------------------
  // 3) Sync scroll (no transforms → no drift)
  // -----------------------------------------
  function syncScroll() {
    const top  = -Math.round(ta.scrollTop)  + 'px';
    const left = -Math.round(ta.scrollLeft) + 'px';
    hl.style.top  = top;
    hl.style.left = left;
    if (hitPre) { hitPre.style.top = top; hitPre.style.left = left; }
  }

  // ------------------------------------
  // 4) Paint pipeline (single RAF commit)
  // ------------------------------------
  let raf = 0;
  function schedulePaint(){
    if (raf) return;
    raf = requestAnimationFrame(() => {
      raf = 0;
      // Render → measure → position
      hl.innerHTML = highlight(ta.value) + '\n'; // keep last line stable
      cloneMetrics();
      syncScroll();
    });
  }

  // ----------------------------
  // 5) Wrap toggle (kept naming)
  // ----------------------------
  function setWrap(on){
    ta.setAttribute('wrap', on ? 'soft' : 'off');
    ta.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    hl.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    if (hitPre) hitPre.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    if (on) ta.scrollLeft = 0;
    schedulePaint();
  }

  if (wrapBtn){
    let wrapped = false;
    wrapBtn.addEventListener('click', () => {
      wrapped = !wrapped;
      document.body.classList.toggle('wrap-on', wrapped);
      wrapBtn.textContent = wrapped ? '⤶ Wrap: On' : '⤶ Wrap: Off';
      setWrap(wrapped);
    });
  }

  // -------------------------------------------
  // 6) Events: input/scroll/resize/theme changes
  // -------------------------------------------
  ta.addEventListener('input',  schedulePaint);
  ta.addEventListener('scroll', () => requestAnimationFrame(syncScroll), { passive:true });
  window.addEventListener('resize', schedulePaint);

  // Initial states
  setWrap(false);      // start with hard wrap off
  schedulePaint();     // initial paint
})();

const log2 = (...a) => {
   
    const msg = `${a.join(" ")}`;
    const out = (typeof document !== "undefined") && document.getElementById && document.getElementById("out");
    if (out){ out.textContent += "\n" + msg; out.scrollTop = out.scrollHeight; }
    else if (typeof console !== "undefined" && console.debug){ console.debug(msg); }
  };





/* ============= Minimal math (column-major) ===================== */
const Mat4 = {
  identity() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); },
  multiply(a, b) { // c = a * b
    const c = new Float32Array(16);
    for (let col = 0; col < 4; col++) {
      const bi = col * 4;
      const b0 = b[bi + 0], b1 = b[bi + 1], b2 = b[bi + 2], b3 = b[bi + 3];
      c[bi + 0] = a[0] * b0 + a[4] * b1 + a[8]  * b2 + a[12] * b3;
      c[bi + 1] = a[1] * b0 + a[5] * b1 + a[9]  * b2 + a[13] * b3;
      c[bi + 2] = a[2] * b0 + a[6] * b1 + a[10] * b2 + a[14] * b3;
      c[bi + 3] = a[3] * b0 + a[7] * b1 + a[11] * b2 + a[15] * b3;
    }
    return c;
  },
  translation(tx, ty, tz) { const m = Mat4.identity(); m[12]=tx; m[13]=ty; m[14]=tz; return m; },
  scale(sx, sy, sz)       { const m = Mat4.identity(); m[0]=sx; m[5]=sy; m[10]=sz; return m; },
  rotX(rad) { const c=Math.cos(rad), s=Math.sin(rad); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); },
  rotY(rad) { const c=Math.cos(rad), s=Math.sin(rad); return new Float32Array([ c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); },
  rotZ(rad) { const c=Math.cos(rad), s=Math.sin(rad); return new Float32Array([ c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1]); }
};

const Vec3 = {
  make(x=0, y=0, z=0) { return { x, y, z }; },
  add(a, b) { return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }; },
  mul(a, b) { return { x: a.x * b.x, y: a.y * b.y, z: a.z * b.z }; }
};
            </script>    
    
            <script>       
            // WebGL Scene Renderer with High-Res Textures, Correct UVs, and Improved Lighting
// ==============================================================================

(() => {
  // ---- Geometry index buffers (vertex order 0..7) ----
  const TRI_IDX = new Uint16Array([
    0,2,1, 0,3,2,  // back
    4,5,6, 4,6,7,  // front
    0,4,7, 0,7,3,  // left
    1,2,6, 1,6,5,  // right
    3,7,6, 3,6,2,  // top
    0,1,5, 0,5,4   // bottom
  ]);
  const EDGE_IDX = new Uint16Array([
    0,1, 1,2, 2,3, 3,0,
    4,5, 5,6, 6,7, 7,4,
    0,4, 1,5, 2,6, 3,7
  ]);

  // ---- Per-triangle UVs aligned 1:1 with TRI_IDX (pre-flattened) ----
  // Each face gets a clean [0,0]-[1,1] mapping (2 tris per face).
  const CUBE_TRI_UVS = new Float32Array([
    // back
    0,0,  1,1,  1,0,
    0,0,  0,1,  1,1,
    // front
    0,0,  1,0,  1,1,
    0,0,  1,1,  0,1,
    // left
    0,0,  1,0,  1,1,
    0,0,  1,1,  0,1,
    // right
    0,0,  1,0,  1,1,
    0,0,  1,1,  0,1,
    // top
    0,0,  1,0,  1,1,
    0,0,  1,1,  0,1,
    // bottom
    0,0,  1,0,  1,1,
    0,0,  1,1,  0,1
  ]);

  // ---- Texture presets (unchanged names; higher-res generators below) ----
  const TEXTURE_PRESETS = {
    // Structural / Building
    roughConcrete:   { fn:"noise",  c1:[0.6,0.6,0.6,1], c2:[0.4,0.4,0.4,1] },
    smoothConcrete:  { fn:"solid",  c1:[0.7,0.7,0.7,1] },
    crackedAsphalt:  { fn:"noise",  c1:[0.1,0.1,0.1,1], c2:[0.2,0.2,0.2,1] },
    redBrickWall:    { fn:"checker",c1:[0.6,0.2,0.2,1], c2:[0.45,0.15,0.15,1] },
    whiteTiles:      { fn:"checker",c1:[0.95,0.95,0.95,1], c2:[0.85,0.85,0.85,1] },
    blueCeramicTile: { fn:"checker",c1:[0.2,0.4,0.8,1], c2:[0.1,0.2,0.5,1] },

    // Metals
    shinySteel:      { fn:"solid",  c1:[0.75,0.75,0.8,1] },
    brushedAluminum: { fn:"noise",  c1:[0.8,0.8,0.85,1], c2:[0.7,0.7,0.75,1] },
    oxidizedCopper:  { fn:"noise",  c1:[0.7,0.3,0.2,1], c2:[0.2,0.5,0.4,1] },
    agedBronze:      { fn:"noise",  c1:[0.5,0.35,0.2,1], c2:[0.25,0.15,0.05,1] },
    shinyGold:       { fn:"solid",  c1:[0.9,0.8,0.25,1] },
    tarnishedSilver: { fn:"noise",  c1:[0.9,0.9,0.9,1], c2:[0.6,0.6,0.65,1] },
    rawIron:         { fn:"solid",  c1:[0.35,0.35,0.4,1] },
    polishedTitanium:{ fn:"solid",  c1:[0.75,0.75,0.85,1] },

    // Glass
    clearGlass:      { fn:"solid",  c1:[0.7,0.9,1,0.2] },
    frostedGlass:    { fn:"noise",  c1:[0.8,0.9,1,0.3], c2:[0.6,0.7,0.8,0.3] },
    tintedGreenGlass:{ fn:"solid",  c1:[0.4,0.7,0.5,0.3] },
    stainedBlueGlass:{ fn:"solid",  c1:[0.2,0.3,0.8,0.4] },

    // Plastics
    glossyWhitePlastic:{ fn:"solid", c1:[0.95,0.95,0.95,1] },
    matteBlackPlastic: { fn:"solid", c1:[0.05,0.05,0.05,1] },
    redABS:            { fn:"solid", c1:[0.9,0.1,0.1,1] },
    bluePVC:           { fn:"solid", c1:[0.1,0.1,0.9,1] },
    translucentPoly:   { fn:"solid", c1:[0.9,0.9,0.9,0.5] },

    // Natural / Ground
    freshGrass:     { fn:"checker",c1:[0.1,0.6,0.1,1], c2:[0.2,0.8,0.2,1] },
    dryGrass:       { fn:"checker",c1:[0.7,0.6,0.2,1], c2:[0.6,0.5,0.15,1] },
    desertSand:     { fn:"noise",  c1:[0.9,0.85,0.6,1], c2:[0.8,0.75,0.5,1] },
    muddySoil:      { fn:"noise",  c1:[0.4,0.25,0.15,1], c2:[0.3,0.2,0.1,1] },
    grayStone:      { fn:"noise",  c1:[0.5,0.5,0.5,1], c2:[0.3,0.3,0.3,1] },
    darkBasalt:     { fn:"noise",  c1:[0.2,0.2,0.2,1], c2:[0.1,0.1,0.1,1] },
    whiteMarble:    { fn:"noise",  c1:[0.95,0.95,0.95,1], c2:[0.75,0.75,0.75,1] },
    greenMarble:    { fn:"noise",  c1:[0.1,0.3,0.2,1], c2:[0.05,0.2,0.1,1] },

    // Wood
    oakPlanks:      { fn:"checker",c1:[0.65,0.45,0.25,1], c2:[0.55,0.35,0.2,1] },
    darkWalnut:     { fn:"checker",c1:[0.35,0.2,0.1,1], c2:[0.25,0.15,0.05,1] },
    pineWood:       { fn:"checker",c1:[0.8,0.65,0.4,1], c2:[0.7,0.55,0.3,1] },
    mahoganyWood:   { fn:"checker",c1:[0.55,0.25,0.15,1], c2:[0.45,0.2,0.1,1] },
    cherryWood:     { fn:"checker",c1:[0.6,0.2,0.2,1], c2:[0.5,0.15,0.15,1] },
    mapleWood:      { fn:"checker",c1:[0.9,0.8,0.6,1], c2:[0.8,0.7,0.5,1] },

    // Elements & FX
    iceBlock:       { fn:"solid",  c1:[0.8,0.9,1,0.5] },
    moltenLava:     { fn:"noise",  c1:[0.9,0.2,0.05,1], c2:[0.2,0.05,0.05,1] },
    deepWater:      { fn:"solid",  c1:[0.1,0.3,0.9,0.5] },
    snowPowder:     { fn:"solid",  c1:[0.98,0.98,1.0,1] },
    fluffyCloud:    { fn:"noise",  c1:[0.95,0.95,0.95,1], c2:[0.8,0.8,0.85,1] },
    mossPatch:      { fn:"noise",  c1:[0.2,0.4,0.2,1], c2:[0.1,0.3,0.1,1] },
    claySoil:       { fn:"solid",  c1:[0.6,0.3,0.2,1] },
    rustyMetal:     { fn:"noise",  c1:[0.6,0.25,0.1,1], c2:[0.4,0.15,0.05,1] },

    // Sci-Fi / Industrial
    carbonFiber:    { fn:"checker",c1:[0.05,0.05,0.05,1], c2:[0.15,0.15,0.15,1] },
    circuitBoard:   { fn:"checker",c1:[0.0,0.4,0.0,1], c2:[0.0,0.6,0.0,1] },
    glowingPanel:   { fn:"solid",  c1:[0.1,0.8,1,0.8] },
    hazardStripe:   { fn:"checker",c1:[0.9,0.8,0.1,1], c2:[0.05,0.05,0.05,1] },
    steelGrid:      { fn:"checker",c1:[0.5,0.5,0.55,1], c2:[0.3,0.3,0.35,1] },
    chromeSurface:  { fn:"solid",  c1:[0.9,0.9,0.95,1] },
  };
  const TEXTURE_NAMES = Object.keys(TEXTURE_PRESETS);

  // ---- Minimal mat4 helpers (same API, kept) ----
  const Mat4 = {
    ident() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); },
    multiply(a,b,out=new Float32Array(16)) {
      const o=out;
      const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
      const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
      const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];
      const b00=b[0],b01=b[1],b02=b[2],b03=b[3];
      const b10=b[4],b11=b[5],b12=b[6],b13=b[7];
      const b20=b[8],b21=b[9],b22=b[10],b23=b[11];
      const b30=b[12],b31=b[13],b32=b[14],b33=b[15];
      o[0]=a00*b00+a10*b01+a20*b02+a30*b03;
      o[1]=a01*b00+a11*b01+a21*b02+a31*b03;
      o[2]=a02*b00+a12*b01+a22*b02+a32*b03;
      o[3]=a03*b00+a13*b01+a23*b02+a33*b03;
      o[4]=a00*b10+a10*b11+a20*b12+a30*b13;
      o[5]=a01*b10+a11*b11+a21*b12+a31*b13;
      o[6]=a02*b10+a12*b11+a22*b12+a32*b13;
      o[7]=a03*b10+a13*b11+a23*b12+a33*b13;
      o[8]=a00*b20+a10*b21+a20*b22+a30*b23;
      o[9]=a01*b20+a11*b21+a21*b22+a31*b23;
      o[10]=a02*b20+a12*b21+a22*b22+a32*b23;
      o[11]=a03*b20+a13*b21+a23*b22+a33*b23;
      o[12]=a00*b30+a10*b31+a20*b32+a30*b33;
      o[13]=a01*b30+a11*b31+a21*b32+a31*b33;
      o[14]=a02*b30+a12*b31+a22*b32+a32*b33;
      o[15]=a03*b30+a13*b31+a23*b32+a33*b33;
      return o;
    },
    perspective(fovyRad, aspect, near, far) {
      const f = 1 / Math.tan(fovyRad/2), nf = 1/(near - far);
      const out = new Float32Array(16);
      out[0]=f/aspect; out[5]=f; out[11]=-1;
      out[10]=(far+near)*nf; out[14]=(2*far*near)*nf;
      return out;
    },
    lookAt(eye, target, up=[0,1,0]) {
      const [ex,ey,ez]=eye,[tx,ty,tz]=target;
      const zx=ex-tx, zy=ey-ty, zz=ez-tz;
      let rl = 1/Math.hypot(zx,zy,zz);
      const zxN=zx*rl, zyN=zy*rl, zzN=zz*rl;
      let xx = up[1]*zzN - up[2]*zyN;
      let xy = up[2]*zxN - up[0]*zzN;
      let xz = up[0]*zyN - up[1]*zxN;
      rl = 1/Math.hypot(xx,xy,xz); xx*=rl; xy*=rl; xz*=rl;
      const yx = zyN*xz - zzN*xy;
      const yy = zzN*xx - zxN*xz;
      const yz = zxN*xy - zyN*xx;
      const out = new Float32Array(16);
      out[0]=xx; out[1]=yx; out[2]=zxN; out[3]=0;
      out[4]=xy; out[5]=yy; out[6]=zyN; out[7]=0;
      out[8]=xz; out[9]=yz; out[10]=zzN; out[11]=0;
      out[12]=-(xx*ex+xy*ey+xz*ez);
      out[13]=-(yx*ex+yy*ey+yz*ez);
      out[14]=-(zxN*ex+zyN*ey+zzN*ez);
      out[15]=1;
      return out;
    }
  };

  // ---- Improved shaders: textured + Blinn-Phong lighting (view space) ----
  const VS_LIT = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aUV;
    uniform mat4 uMVP;
    uniform mat4 uMV;
    uniform mat3 uNormalMatrix;
    varying vec2 vUV;
    varying vec3 vN;
    varying vec3 vPosVS;
    void main() {
      vUV = aUV;
      vec4 posVS = uMV * vec4(aPosition, 1.0);
      vPosVS = posVS.xyz;
      vN = normalize(uNormalMatrix * aNormal);
      gl_Position = uMVP * vec4(aPosition, 1.0);
    }
  `;
  const FS_LIT = `
    precision mediump float;
    varying vec2 vUV;
    varying vec3 vN;
    varying vec3 vPosVS;
    uniform sampler2D uTex;
    uniform vec3 uLightDirVS;   // direction *toward* the surface in view space (normalized)
    uniform vec3 uLightColor;   // e.g., vec3(1.0)
    uniform vec3 uAmbient;      // e.g., vec3(0.15)
    uniform float uSpecPower;   // e.g., 48.0
    uniform float uSpecIntensity; // e.g., 0.35
    uniform float uGamma;       // 2.2

    void main(){
      vec4 albedo = texture2D(uTex, vUV);

      vec3 N = normalize(vN);
      vec3 L = normalize(uLightDirVS);
      vec3 V = normalize(-vPosVS);
      vec3 H = normalize(L + V);

      float NdotL = max(dot(N, L), 0.0);
      float NdotH = max(dot(N, H), 0.0);

      vec3 diffuse  = albedo.rgb * uLightColor * NdotL;
      float spec    = pow(NdotH, uSpecPower) * uSpecIntensity;
      vec3 specular = uLightColor * spec;

      vec3 colorLin = albedo.rgb * uAmbient + diffuse + specular;

      // simple gamma correction
      vec3 color = pow(colorLin, vec3(1.0 / uGamma));
      gl_FragColor = vec4(color, albedo.a);
    }
  `;

  function compile(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error("Shader compile failed:\n" + info);
    }
    return s;
  }
  function program(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl, gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compile(gl, gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(p);
      gl.deleteProgram(p);
      throw new Error("Program link failed:\n" + info);
    }
    return p;
  }

  class WebGLSceneRenderer {
    constructor(canvasOrSelector, opts={}) {
      this.canvas = (typeof canvasOrSelector === "string")
        ? document.querySelector(canvasOrSelector)
        : canvasOrSelector;
      if (!this.canvas) throw new Error("Canvas not found.");

      this.dpr = Math.max(1, Math.min(window.devicePixelRatio||1, 2));
      const gl = this.canvas.getContext("webgl", {
        antialias:true, depth:true, alpha:false, premultipliedAlpha:false
      });
      if (!gl) throw new Error("WebGL not supported.");
      this.gl = gl;

      // Programs + locations
      this.litProg = program(gl, VS_LIT, FS_LIT);
      this.litLoc = {
        aPosition: gl.getAttribLocation(this.litProg, "aPosition"),
        aNormal:   gl.getAttribLocation(this.litProg, "aNormal"),
        aUV:       gl.getAttribLocation(this.litProg, "aUV"),
        uMVP:      gl.getUniformLocation(this.litProg, "uMVP"),
        uMV:       gl.getUniformLocation(this.litProg, "uMV"),
        uNormalMatrix: gl.getUniformLocation(this.litProg, "uNormalMatrix"),
        uTex:      gl.getUniformLocation(this.litProg, "uTex"),
        uLightDirVS:   gl.getUniformLocation(this.litProg, "uLightDirVS"),
        uLightColor:   gl.getUniformLocation(this.litProg, "uLightColor"),
        uAmbient:      gl.getUniformLocation(this.litProg, "uAmbient"),
        uSpecPower:    gl.getUniformLocation(this.litProg, "uSpecPower"),
        uSpecIntensity:gl.getUniformLocation(this.litProg, "uSpecIntensity"),
        uGamma:        gl.getUniformLocation(this.litProg, "uGamma"),
      };

      // Buffers
      this.triPosBuf = gl.createBuffer();
      this.triUVBuf  = gl.createBuffer();
      this.triNrmBuf = gl.createBuffer();
      this.linePosBuf = gl.createBuffer();

      // Draw-call batching
      this.drawCalls = []; // [{ tex, first, count, alpha }]
      this.opaqueCalls = [];
      this.transpCalls = [];

      // State
      this.wireframe = (opts.wireframe !== false);
      this.lineColor = new Float32Array((opts.lineColor||[0,0,0,0.3]));
      this.target = [0,0,0];
      this.radius = 6; this.phi = Math.PI/6; this.theta = Math.PI/4;
      this.proj = Mat4.perspective(60*Math.PI/180, 1, 0.01, 100);
      this.view = Mat4.lookAt([0,0,this.radius], this.target);
      this.mvp  = Mat4.ident();
      this.mv   = Mat4.ident();

      // Textures
      this.textures = Object.create(null);
      this.textureAlpha = Object.create(null);
      this.createAllPresetTextures();

      // Controls + GL state
      this.#initControls();
      this.resize();
      window.addEventListener("resize", () => this.resize());
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      gl.clearColor(0.06,0.07,0.09,1);

      // Scene
      this.scene = null;
      this.triCount = 0;
      this.lineCount = 0;

      // Animation loop
      this.needsRedraw = true;
      const loop = () => {
        if (this.needsRedraw) { this.render(); this.needsRedraw = false; }
        requestAnimationFrame(loop);
      };
      loop();
    }

    // ---------------- Public API ----------------
    setWireframe(on=true){ this.wireframe = !!on; this.invalidate(); }
    setLineColor(r=0,g=0,b=0,a=0.3){ this.lineColor.set([r,g,b,a]); this.invalidate(); }
    setScene(scene) {
      if (!scene || typeof scene.getAll !== "function")
        throw new Error("setScene expects a Scene instance with getAll().");
      this.scene = scene;
      this.#rebuildBuffers();
      this.invalidate();
    }
    invalidate(){ this.needsRedraw = true; }

    setTexture(name, texData /* {w,h,data:Uint8Array} */){
      this.textures[name] = this.#uploadTexture(texData); // generates mipmaps
      this.textureAlpha[name] = 1.0;
      this.invalidate();
    }

    createRandomTexturePattern(name=null){
      const t = this.#uploadTexture(this.#makeRandomPattern());
      if (name) this.textures[name] = t;
      return t;
    }

    createAllPresetTextures() {
      for (const [name, preset] of Object.entries(TEXTURE_PRESETS)) {
       log2(`Adding texture ${name}.`);
//        if (this.textures[name]) continue;
        let data;
        switch (preset.fn) {
          case "solid":   data = this.#makeSolid(preset.c1); break;
          case "checker": data = this.#makeChecker(preset.c1, preset.c2); break;
          case "noise":   data = this.#makeNoise(preset.c1, preset.c2); break;
          default:        data = this.#makeRandomPattern();
        }
        this.textures[name] = this.#uploadTexture(data);
        const a1 = (preset.c1 && preset.c1[3] != null) ? preset.c1[3] : 1.0;
        const a2 = (preset.c2 && preset.c2[3] != null) ? preset.c2[3] : a1;
        this.textureAlpha[name] = (a1 + a2) * 0.5;
      }
    }

    // ---------------- Internals ----------------
    resize() {
      const {canvas, gl, dpr} = this;
      const w = Math.floor((canvas.clientWidth||canvas.width) * dpr);
      const h = Math.floor((canvas.clientHeight||canvas.height) * dpr);
      if (w && h && (canvas.width !== w || canvas.height !== h)) {
        canvas.width = w; canvas.height = h;
        gl.viewport(0,0,w,h);
        this.proj = Mat4.perspective(60*Math.PI/180, w/Math.max(1,h), 0.01, 100);
        this.invalidate();
      }
    }

    #initControls() {
      const canvas = this.canvas;
      let dragging=false, panMode=false, lastX=0, lastY=0;
      canvas.addEventListener("mousedown",(e)=>{
        dragging = true;
        panMode = (e.button===2 || e.ctrlKey || e.metaKey);
        lastX=e.clientX; lastY=e.clientY; e.preventDefault();
      });
      window.addEventListener("mouseup", ()=>{ dragging=false; });
      window.addEventListener("mousemove",(e)=>{
        if (!dragging) return;
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        if (panMode){
          const panScale = this.radius*0.0015;
          this.target[0]-=dx*panScale; this.target[1]+=dy*panScale;
        } else {
          this.theta -= dx*0.005;
          this.phi   -= dy*0.005;
          const EPS=0.001;
          this.phi = Math.max(EPS, Math.min(Math.PI-EPS, this.phi));
        }
        this.invalidate();
      }, {passive:false});
      canvas.addEventListener("contextmenu",(e)=>e.preventDefault());
      canvas.addEventListener("wheel",(e)=>{
        const s = Math.exp(-e.deltaY*0.0015);
        this.radius = Math.max(0.5, Math.min(100, this.radius*s));
        this.invalidate();
        e.preventDefault();
      }, {passive:false});
    }

    // ---- High-res procedural textures (power-of-two + mipmaps) ----
    #makeSolid([r,g,b,a]){
      const w=4,h=4, arr=new Uint8Array(w*h*4);
      for (let i=0;i<w*h;i++){
        arr[i*4]=r*255; arr[i*4+1]=g*255; arr[i*4+2]=b*255; arr[i*4+3]=a*255;
      }
      return {w,h,data:arr};
    }
    #makeChecker(c1,c2,texSize=128,cells=8){
      const w=texSize,h=texSize, arr=new Uint8Array(w*h*4);
      const cw = w/cells, ch = h/cells;
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const cx=(x/cw)|0, cy=(y/ch)|0;
          const c = ((cx+cy)&1) ? c1 : c2;
          const i=(y*w+x)*4;
          arr[i]=c[0]*255; arr[i+1]=c[1]*255; arr[i+2]=c[2]*255; arr[i+3]=c[3]*255;
        }
      }
      return {w,h,data:arr};
    }
    #makeNoise(cA,cB=[1,1,1,1],texSize=128){
      const w=texSize,h=texSize, arr=new Uint8Array(w*h*4);
      for (let i=0;i<w*h;i++){
        const t=Math.random();
        const r=cA[0]*(1-t)+cB[0]*t, g=cA[1]*(1-t)+cB[1]*t, b=cA[2]*(1-t)+cB[2]*t, a=cA[3]*(1-t)+cB[3]*t;
        arr[i*4]=r*255; arr[i*4+1]=g*255; arr[i*4+2]=b*255; arr[i*4+3]=a*255;
      }
      return {w,h,data:arr};
    }
    #makeLinearGradient(top,bot,texSize=128){
      const w=texSize,h=texSize, arr=new Uint8Array(w*h*4);
      for (let y=0;y<h;y++){
        const t=y/(h-1);
        const r=top[0]*(1-t)+bot[0]*t, g=top[1]*(1-t)+bot[1]*t, b=top[2]*(1-t)+bot[2]*t, a=top[3]*(1-t)+bot[3]*t;
        for (let x=0;x<w;x++){
          const i=(y*w+x)*4;
          arr[i]=r*255; arr[i+1]=g*255; arr[i+2]=b*255; arr[i+3]=a*255;
        }
      }
      return {w,h,data:arr};
    }
    #makeRandomPattern(){
      const choice = Math.floor(Math.random()*4);
      if (choice===0) return this.#makeNoise([Math.random(),Math.random(),Math.random(),1],[1,1,1,1],128);
      if (choice===1) return this.#makeChecker([Math.random(),Math.random(),Math.random(),1],[Math.random(),Math.random(),Math.random(),1],128,8);
      if (choice===2) return this.#makeLinearGradient([Math.random(),Math.random(),Math.random(),1],[Math.random(),Math.random(),Math.random(),1],128);
      return this.#makeNoise([0.5,0.5,0.5,1],[0.2,0.2,0.2,1],128);
    }
    #uploadTexture({w,h,data}){
      const gl=this.gl, tex=gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D,tex);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,data);

      // High quality sampling + mipmaps (requires power-of-two)
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);

      gl.bindTexture(gl.TEXTURE_2D,null);
      return tex;
    }

    getTexture(name) {
      if (!this.textures[name]) {
        if (TEXTURE_PRESETS[name]) {
          const p = TEXTURE_PRESETS[name];
          let data;
          if (p.fn==="solid")   data = this.#makeSolid(p.c1);
          if (p.fn==="checker") data = this.#makeChecker(p.c1,p.c2);
          if (p.fn==="noise")   data = this.#makeNoise(p.c1,p.c2);
          this.textures[name] = this.#uploadTexture(data);
          const a1 = (p.c1?.[3] ?? 1.0), a2 = (p.c2?.[3] ?? a1);
          this.textureAlpha[name] = (a1 + a2) * 0.5;
        } else {
          console.warn(`Unknown texture "${name}", using random pattern.`);
          this.textures[name] = this.createRandomTexturePattern(name);
          this.textureAlpha[name] = 1.0;
        }
      }
     else {
         log2(`Found texture ${name}.`);
      }
      return this.textures[name];
    }

    // ---- Build GPU buffers (positions, UVs, FLAT normals) + batches ----
    #rebuildBuffers() {
      const items = this.scene ? this.scene.getAll() : [];
      const triPositions = [];
      const triUVs = [];
      const triNormals = [];
      const linePositions = [];
      this.drawCalls.length = 0;
      this.opaqueCalls.length = 0;
      this.transpCalls.length = 0;

      if (!items.length) {
        this.triCount = 0; this.lineCount = 0;
        this.#uploadAll(new Float32Array(0), new Float32Array(0), new Float32Array(0), new Float32Array(0));
        return;
      }

      let vtxCount = 0;

      for (const it of items) {
        // Map numeric index → preset name, else treat as string
        const texName = (typeof it.texIndex === "number")
          ? TEXTURE_NAMES[it.texIndex % TEXTURE_NAMES.length]
          : String(it.texIndex);
        const tex = this.getTexture(texName);
        const repeat = Math.max(1, it.texRepeat|0 || 1);

        const start = vtxCount;

        // For each triangle: push pos/uv, compute flat normal and push 3 times
        for (let tri=0; tri<TRI_IDX.length; tri+=3) {
          const i0 = TRI_IDX[tri], i1 = TRI_IDX[tri+1], i2 = TRI_IDX[tri+2];
          const v0 = it.verts[i0], v1 = it.verts[i1], v2 = it.verts[i2];

          // positions
          triPositions.push(v0[0],v0[1],v0[2], v1[0],v1[1],v1[2], v2[0],v2[1],v2[2]);

          // UVs (pre-baked): index directly
          const u0 = CUBE_TRI_UVS[(tri+0)*2], v0u = CUBE_TRI_UVS[(tri+0)*2+1];
          const u1 = CUBE_TRI_UVS[(tri+1)*2], v1u = CUBE_TRI_UVS[(tri+1)*2+1];
          const u2 = CUBE_TRI_UVS[(tri+2)*2], v2u = CUBE_TRI_UVS[(tri+2)*2+1];
          triUVs.push(u0*repeat, v0u*repeat, u1*repeat, v1u*repeat, u2*repeat, v2u*repeat);

          // flat normal per triangle
          const ax=v1[0]-v0[0], ay=v1[1]-v0[1], az=v1[2]-v0[2];
          const bx=v2[0]-v0[0], by=v2[1]-v0[1], bz=v2[2]-v0[2];
          let nx = ay*bz - az*by;
          let ny = az*bx - ax*bz;
          let nz = ax*by - ay*bx;
          const invLen = 1/Math.hypot(nx,ny,nz);
          nx*=invLen; ny*=invLen; nz*=invLen;
          triNormals.push(nx,ny,nz, nx,ny,nz, nx,ny,nz);
        }

        vtxCount += TRI_IDX.length;

        // Lines
        for (let i=0;i<EDGE_IDX.length;i++){
          const v = it.verts[EDGE_IDX[i]];
          linePositions.push(v[0],v[1],v[2]);
        }

        const alphaHint = (this.textureAlpha && this.textureAlpha[texName] != null)
          ? this.textureAlpha[texName]
          : 1.0;

        const dc = { tex, first: start, count: TRI_IDX.length, alpha: alphaHint };
        this.drawCalls.push(dc);
        if (alphaHint < 1.0) this.transpCalls.push(dc); else this.opaqueCalls.push(dc);
      }

      this.triCount  = triPositions.length / 3;
      this.lineCount = linePositions.length / 3;

      this.#uploadAll(
        new Float32Array(triPositions),
        new Float32Array(triUVs),
        new Float32Array(triNormals),
        new Float32Array(linePositions)
      );
    }

    #uploadAll(posArray, uvArray, nrmArray, lineArray){
      const gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.triPosBuf);
      gl.bufferData(gl.ARRAY_BUFFER, posArray, gl.STATIC_DRAW);

      gl.bindBuffer(gl.ARRAY_BUFFER, this.triUVBuf);
      gl.bufferData(gl.ARRAY_BUFFER, uvArray, gl.STATIC_DRAW);

      gl.bindBuffer(gl.ARRAY_BUFFER, this.triNrmBuf);
      gl.bufferData(gl.ARRAY_BUFFER, nrmArray, gl.STATIC_DRAW);

      gl.bindBuffer(gl.ARRAY_BUFFER, this.linePosBuf);
      gl.bufferData(gl.ARRAY_BUFFER, lineArray, gl.STATIC_DRAW);
    }

    render() {
      const gl = this.gl;
      gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
      if (!this.triCount && !this.lineCount) return;

      // camera
      const x = this.target[0] + this.radius*Math.sin(this.phi)*Math.cos(this.theta);
      const y = this.target[1] + this.radius*Math.cos(this.phi);
      const z = this.target[2] + this.radius*Math.sin(this.phi)*Math.sin(this.theta);
      this.view = Mat4.lookAt([x,y,z], this.target);
      // model is identity => MV = view
      this.mv = this.view;
      this.mvp = Mat4.multiply(this.proj, this.view, this.mvp);

      // derive normal matrix (upper-left 3x3 of MV; MV is orthonormal here)
      const nm = new Float32Array([
        this.mv[0], this.mv[1], this.mv[2],
        this.mv[4], this.mv[5], this.mv[6],
        this.mv[8], this.mv[9], this.mv[10],
      ]);

      // lighting setup (view space): light coming from above-left-front
      const lightDirVS = new Float32Array([0.5, 0.8, 0.6]); // will be normalized in shader uniforms
      const lightLen = Math.hypot(lightDirVS[0],lightDirVS[1],lightDirVS[2]);
      lightDirVS[0]/=lightLen; lightDirVS[1]/=lightLen; lightDirVS[2]/=lightLen;

      // --- Opaque geometry ---
      gl.useProgram(this.litProg);
      gl.uniformMatrix4fv(this.litLoc.uMVP,false,this.mvp);
      gl.uniformMatrix4fv(this.litLoc.uMV,false,this.mv);
      gl.uniformMatrix3fv(this.litLoc.uNormalMatrix,false,nm);
      gl.uniform3f(this.litLoc.uLightDirVS, lightDirVS[0], lightDirVS[1], lightDirVS[2]);
      gl.uniform3f(this.litLoc.uLightColor, 1.0, 1.0, 1.0);
      gl.uniform3f(this.litLoc.uAmbient, 0.15, 0.15, 0.16);
      gl.uniform1f(this.litLoc.uSpecPower, 48.0);
      gl.uniform1f(this.litLoc.uSpecIntensity, 0.35);
      gl.uniform1f(this.litLoc.uGamma, 2.2);

      gl.activeTexture(gl.TEXTURE0);
      gl.uniform1i(this.litLoc.uTex,0);

      // bind attribs
      gl.bindBuffer(gl.ARRAY_BUFFER,this.triPosBuf);
      gl.enableVertexAttribArray(this.litLoc.aPosition);
      gl.vertexAttribPointer(this.litLoc.aPosition,3,gl.FLOAT,false,0,0);

      gl.bindBuffer(gl.ARRAY_BUFFER,this.triUVBuf);
      gl.enableVertexAttribArray(this.litLoc.aUV);
      gl.vertexAttribPointer(this.litLoc.aUV,2,gl.FLOAT,false,0,0);

      gl.bindBuffer(gl.ARRAY_BUFFER,this.triNrmBuf);
      gl.enableVertexAttribArray(this.litLoc.aNormal);
      gl.vertexAttribPointer(this.litLoc.aNormal,3,gl.FLOAT,false,0,0);

      gl.disable(gl.BLEND);
      gl.depthMask(true);
      for (const dc of this.opaqueCalls){
        gl.bindTexture(gl.TEXTURE_2D, dc.tex);
        gl.drawArrays(gl.TRIANGLES, dc.first, dc.count);
      }

      // --- Transparent geometry ---
      if (this.transpCalls.length){
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(false);
        for (const dc of this.transpCalls){
          gl.bindTexture(gl.TEXTURE_2D, dc.tex);
          gl.drawArrays(gl.TRIANGLES, dc.first, dc.count);
        }
        gl.depthMask(true);
        gl.disable(gl.BLEND);
      }

      // (Wireframe overlay could be re-enabled here if desired)
    }
  }

  // Expose
  window.WebGLSceneRenderer = WebGLSceneRenderer;
})();
            </script>    
    
            <script>       
            // Scene 
"use strict";

// --- Cube vertices (unit cube centered at origin) ---
const cubeVerts = [
  [-0.5, -0.5, -0.5],
  [ 0.5, -0.5, -0.5],
  [ 0.5,  0.5, -0.5],
  [-0.5,  0.5, -0.5],
  [-0.5, -0.5,  0.5],
  [ 0.5, -0.5,  0.5],
  [ 0.5,  0.5,  0.5],
  [-0.5,  0.5,  0.5],
];

// --- Multiply a point by a column-major 4x4 (v' = M * [x y z 1]^T) ---
function transformPoint(M, v, w = 1) {
  const x = v[0], y = v[1], z = v[2];
  const xp = M[0]*x + M[4]*y + M[8]*z  + M[12]*w;
  const yp = M[1]*x + M[5]*y + M[9]*z  + M[13]*w;
  const zp = M[2]*x + M[6]*y + M[10]*z + M[14]*w;
  const wp = M[3]*x + M[7]*y + M[11]*z + M[15]*w; // stays 1 for affine
  return (wp !== 0 && wp !== 1) ? [xp/wp, yp/wp, zp/wp] : [xp, yp, zp];
}

class Scene {
  constructor() {
    this.items = [];
  }

  /**
   * Add a cube-like primitive with two-stage transform.
   * - Always applies transform1 to all verts.
   * - Then applies transform2 selectively based on type:
   *    Cube : if z > 0
   *    CubeX: if x > 0.5 (after transform1)
   *    CubeY: if y > 0.5 (after transform1)
   */
  add(type, transform1, transform2,transform3, texIndex, arg, val) {
    let baseVerts = cubeVerts;
  

   if (type === "Cube") {
     let transformVerts = baseVerts.map(v => {
        return (v[2] > 0) ? transformPoint(transform2, v) : v;
      });
     transformVerts = transformVerts.map(v => {
        return (v[1] > 0) ? transformPoint(transform3, v) : v;
      });
      const finalVerts = transformVerts.map(v => {
        return  transformPoint(transform1,v);
      });

      const flat = new Float32Array(finalVerts.flat());
      return this.#pushItem(type, transform1, transform2,transform3, finalVerts, flat, texIndex, arg, val);

    } else if (type === "CubeX") {
      const shiftedVerts = baseVerts.map(([x, y, z]) => [x + 0.5, y, z]);
      const transformVerts = shiftedVerts.map(v => {
        return (v[0] > 0.5) ? transformPoint(transform2, v) : v;
      });
      const finalVerts = transformVerts.map(v => {
        return  transformPoint(transform1, v);
      });

      const flat = new Float32Array(finalVerts.flat());
      return this.#pushItem(type, transform1, transform2,transform3, finalVerts, flat, texIndex, arg, val);

    } else if (type === "CubeY") {
      const shiftedVerts = baseVerts.map(([x, y, z]) => [x, y + 0.5, z]);
      const transformVerts = shiftedVerts.map(v => {
        return (v[1] > 0.5) ? transformPoint(transform2, v) : v;
      });
      const finalVerts = transformVerts.map(v => {
        return  transformPoint(transform1, v);
      });
      const flat = new Float32Array(finalVerts.flat()); // fixed: flatten final, not shifted
      return this.#pushItem(type, transform1, transform2,transform3, finalVerts, flat, texIndex, arg, val);

    } else {
      throw new Error(`Scene.add: unknown type "${type}"`);
    }
  }

  #pushItem(type, transform1, transform2,transform3, verts, flat, texIndex, arg, val) {
    const item = {
      type,
      transform1,
      transform2,
      transform3,
      verts,           // array of 8 [x,y,z]
      flat,            // Float32Array(24) flattened xyz
      texIndex,
      arg: (Number(arg) || 0) | 0,
      val: Number.isFinite(val) ? Number(val) : 0
    };
    this.items.push(item);
    return item;
  }

  clear() { this.items.length = 0; }
  getAll() { return this.items.slice(); }
}
            </script>    
    
            <script>       
            /*Scope================================================= */

//                                               Scope Class 

//         (C++ port) 
/* ======================================================= */
class Scope {
  constructor(other = null) {
    if (other instanceof Scope) {
      this.position   = Vec3.make(other.position.x, other.position.y, other.position.z);
      this.size       = Vec3.make(other.size.x, other.size.y, other.size.z);
      this.size2      = Vec3.make(other.size2.x, other.size2.y, other.size2.z);
      this.x          = Vec3.make(other.x.x, other.x.y, other.x.z);
      this.y          = Vec3.make(other.y.x, other.y.y, other.y.z);
      this.z          = Vec3.make(other.z.x, other.z.y, other.z.z);
      this.anglex     = other.anglex; this.angley = other.angley; this.anglez = other.anglez;
      this.Transform  = new Float32Array(other.Transform);
      this.Transform2 = new Float32Array(other.Transform2);
      this.Transform3 = new Float32Array(other.Transform3);
    } else {
      this.position   = Vec3.make(0, 0, 0);
      this.size       = Vec3.make(1, 1, 1);
      this.size2      = Vec3.make(1, 1, 1);
      this.x          = Vec3.make(1, 0, 0);
      this.y          = Vec3.make(0, 1, 0);
      this.z          = Vec3.make(0, 0, 1);
      this.anglex = 0; this.angley = 0; this.anglez = 0;
      this.Transform  = Mat4.identity();
      this.Transform2 = Mat4.identity();
      this.Transform3 = Mat4.identity();
    }
  }
  static #degToRad(deg) { return (deg * Math.PI) / 180.0; }
  static #wrap360(deg)  { let d = deg % 360; return d < 0 ? d + 360 : d; }

  T(v) {
    const M = Mat4.translation(v.x, v.y, v.z);
    this.Transform  = Mat4.multiply(this.Transform,  M);
    //this.Transform2 = Mat4.multiply(this.Transform2, M);
    this.position   = Vec3.add(this.position, v);
  }
  S(v) {
    this.size = Vec3.mul(this.size, v);
    const M = Mat4.scale(v.x, v.y, v.z);
    this.Transform  = Mat4.multiply(this.Transform,  M);
   // this.Transform2 = Mat4.multiply(this.Transform2, M);
    //this.size2 = Vec3.make(this.size.x, this.size.y, this.size.z);
  }
  DS(v) {
    this.size2 = Vec3.mul(this.size2, v);
    const M = Mat4.scale(v.x, v.y, v.z);
    this.Transform2  = M;
  }
DT(v){
   this.size2 = Vec3.mul(this.size2, v);
 const M = Mat4.scale(v.x, v.y, v.z);

        this.Transform3  =M;
 }
  Rx(angleDeg) {
    this.anglex = Scope.#wrap360(angleDeg);
    const r = Scope.#degToRad(this.anglex);
    this.Transform  = Mat4.multiply(this.Transform,  Mat4.rotX(r));
//   this.Transform2 = Mat4.multiply(this.Transform2, Mat4.rotX(r));
    const c = Math.cos(r), s = Math.sin(r);
    this.x = Vec3.make(1, 0, 0);
    this.y = Vec3.make(0,  c, s);
    this.z = Vec3.make(0, -s, c);
  }
  Ry(angleDeg) {
    this.angley = Scope.#wrap360(angleDeg);
    const r = Scope.#degToRad(this.angley);
    this.Transform  = Mat4.multiply(this.Transform,  Mat4.rotY(r));
   // this.Transform2 = Mat4.multiply(this.Transform2, Mat4.rotY(r));
    const c = Math.cos(r), s = Math.sin(r);
    this.x = Vec3.make( c, 0, -s);
    this.y = Vec3.make( 0, 1,  0);
    this.z = Vec3.make( s, 0,  c);
  }
  Rz(angleDeg) {
    this.anglez = Scope.#wrap360(angleDeg);
    const r = Scope.#degToRad(this.anglez);
    this.Transform  = Mat4.multiply(this.Transform,  Mat4.rotZ(r));
   // this.Transform2 = Mat4.multiply(this.Transform2, Mat4.rotZ(r));
    const c = Math.cos(r), s = Math.sin(r);
    this.x = Vec3.make( c, s, 0);
    this.y = Vec3.make(-s, c, 0);
    this.z = Vec3.make( 0, 0, 1);
  }

  getTransform()  { return this.Transform; }
  getTransform2() { return this.Transform2; }
  getTransform3() { return this.Transform3; }
  getPosition()   { return Vec3.make(this.position.x, this.position.y, this.position.z); }
  setPosition(pos){ this.position = Vec3.make(pos.x, pos.y, pos.z); return this.getPosition(); }
  getSize()       { return Vec3.make(this.size.x, this.size.y, this.size.z); }
}
/* ======================================================= */


//                                        Context Class(scope stack) 


/* ======================================================= */
class Context {
  constructor() { this.stack = [ new Scope() ]; }
  current() { return this.stack[this.stack.length - 1]; }
  getCurrentScope() { return this.current(); }
  push() { this.stack.push(new Scope(this.current())); return this.current(); }
  pop()  { if (this.stack.length > 1) this.stack.pop(); return this.current(); }
  pushScope() { return this.push(); }
  popScope()  { return this.pop(); }
  newScope()  { this.stack.push(new Scope()); return this.current(); } // fresh identity
}



/* ======================================================= */

//                                         Error Functions

/* ======================================================= */


class SolutionError extends Error {
  constructor(message, idx = -1, expr = "") {
    const where = (idx >= 0 && expr)
      ? ` at col ${idx + 1}:\n${expr}\n${" ".repeat(idx)}^`
      : "";
    super(`${message}${where}`); this.name = "SolutionError";
  }
}
class ParseError extends Error {
  constructor(message, line = 0, col = 0, snippet = "") {
    super(message); this.name = "ParseError"; this.line = line; this.col = col; this.snippet = snippet;
  }
}
class RuntimeGrammarError extends Error { constructor(message){ super(message); this.name="RuntimeGrammarError"; } }
const ErrorReporter = {
  caret(line, col) { return `${line}\n${" ".repeat(Math.max(0, col))}^`; },
  fromToken(msg, tok) { return new ParseError(msg, tok.line, tok.col, this.caret(tok.sourceLine, tok.col)); }
};
function errorout(e) {
  const hasConsole = typeof console !== "undefined";
  if (e instanceof ParseError) {
    if (hasConsole && console.warn) console.warn(`[ParseError] ${e.message} (line ${e.line}, col ${e.col})\n${e.snippet}`);
  } else {
    if (hasConsole && console.warn) console.warn(String(e));
  }
}
            </script>    
    
            <script>       
            /*Variable========================================== */

//                                                           Variable Class

/* ======================================================= */
const variable_list = [];
const full_variable_list = [];

class Variable {
  constructor(name, min, max, i) {
    if (typeof max==="undefined" && typeof i==="undefined") {
      this.var_name=name; this.min=0; this.max=0; this.value=min; this.instance_count=0; this.integer=false; return;
    }
    this.var_name=name; this.min=min; this.max=max; this.integer=!!i; this.instance_count=0;
    const u=RNG.random();
    this.value = this.integer
      ? Math.floor(u*(Math.floor(max)-Math.ceil(min)+1))+Math.ceil(min)
      : u*(max-min)+min;
  }
  getRandom() {
    const u=RNG.random();
    return this.integer
      ? Math.floor(u*(Math.floor(this.max)-Math.ceil(this.min)+1))+Math.ceil(this.min)
      : u*(this.max-this.min)+this.min;
  }
}
function findVariableForward(var_name){
 for (let i=0;i<variable_list.length;i++)
    if (variable_list[i].var_name===var_name) 
    return i; 
return -1; 
}

function removeVariable(var_name){
  for (let i=variable_list.length-1;i>=0;i--){
    if (variable_list[i].var_name===var_name && variable_list[i].max===variable_list[i].min) { variable_list.splice(i,1); return; }
  }
}
function addVariable(var_name,min,max,integer){
  if (findVariableForward(var_name)===-1){
    const v=new Variable(var_name,min,max,integer); v.value=v.getRandom();
    variable_list.push(v); full_variable_list.push(v);

  }
}
function addVariableInstance(var_name){
  const idx=findVariableForward(var_name); if (idx!==-1){

    const ref=variable_list[idx], v=new Variable(var_name, ref.getRandom());
    variable_list.push(v); full_variable_list.push(v);


  }
}
            </script>    
    
            <script>       
            /* ================================================== */

//                                        Substitution (instrumented) 

/* ================================================== */
function replacevars(s) {

  s = String(s);

  for (let i = variable_list.length - 1; i >= 0; i--) {
    const v = variable_list[i];

      const name = v.var_name;
      const pos = s.indexOf(name);

      if (pos !== -1) {
        const before = s;
        s = s.slice(0, pos) + String(v.value) + s.slice(pos + name.length);

        break;
      }
    
  }

  return s;
}


function replacevars_ampersand(s) {
  s = String(s);
 // ReplaceVarsDebug.group(`replacevars_ampersand IN="${s}"`);
  for (let i = 0; i < variable_list.length; i++) {
    const v = variable_list[i];
    const name = v.var_name;
    const tag = "&" + name;
    const pos = s.indexOf(tag);
//    ReplaceVarsDebug.log(`scan[${i}] tag=${tag} pos=${pos}`);
    if (pos !== -1) {
      const rnd = v.getRandom();
      const before = s;
      s = s.slice(0, pos) + String(rnd) + s.slice(pos + tag.length);
   //   ReplaceVarsDebug.log(`replaced "${tag}" at ${pos} with ${rnd}:`, `before="${before}"`, `after="${s}"`);
      break;
    }
  }
//  ReplaceVarsDebug.groupEnd();
  return s;
}

/* -------- Robust evaluation that replaces ALL identifiers with boundaries -------- */
function MathS2_js(input){
  const X = new Solution();
  let s = String(input);

s=replacevars(replacevars(replacevars(replacevars(replacevars(replacevars( replacevars(s)))))));

  const out = X.Process(s);
  if (!Number.isFinite(out)) {
    if (typeof console !== "undefined" && console.warn) {
      console.warn("[MathS2_js] Non-finite evaluation:", { input, substituted: s, out });
    }
    return 0;
  }
  return out; // return NUMBER
}
            </script>    
    
            <script>       
            /* ================= RNG (guard zero state) ====================== */
const RNG = (() => {
  const UINT32 = 0x100000000;
  const GOLDEN = 0x9e3779b9 | 0;
  let state = ((0x12345678 ^ Date.now()) | 0) ^ GOLDEN;
  const nz = x => ((x|0) === 0 ? GOLDEN : (x|0));
  state = nz(state);
  function xorshift32() {
    let x = state | 0;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    state = nz(x);
    return (x >>> 0) / UINT32;
  }
  return {
    random() { return xorshift32(); },
    setSeed(seed) { const s = Number.isFinite(seed) ? (seed >>> 0) : (Date.now() >>> 0); state = nz(((s ^ GOLDEN) | 0)); }
  };
})();

/* ====================== Math evaluator ====================== */
class Solution {
  constructor() {
    this.precedence = { "+":1, "-":1, "*":2, "/":2, "^":3 };
    this.rightAssoc = { "^": true };
    this.functions = new Set(["sin","cos"]);
    this.eps = 1e-6;
  }
  Process(input) {
    const expr = String(input ?? "").trim();
    if (!expr) return 0;
    try {
      const tokens = this.#tokenize(expr);
      const rpn = this.#toRPN(tokens, expr);
      let value = this.#evalRPN(rpn, expr);
      if (Math.abs(value) < this.eps) value = 0;
   //  log2(`process( ${input} )=${value}`);
      return value;
    } catch (e) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(e instanceof SolutionError ? e.message : String(e));
      }
      return 0;
    }
  }
  #tokenize(expr) {
  const out = [],
        isD = c => c >= "0" && c <= "9",
        isA = c => /[A-Za-z_]/.test(c),
        isAB= c => /[A-Za-z0-9_]/.test(c);

  let i = 0, prev = "START";
  const n = expr.length;

  while (i < n) {
    const ch = expr[i];

    // whitespace
    if (/\s/.test(ch)) { i++; continue; }



    // numbers (incl. .5)
    if (isD(ch) || (ch === "." && isD(expr[i+1] || ""))) {
      const s = i;
      i = this.#readNum(expr, i);
      const v = Number(expr.slice(s, i));
      if (!Number.isFinite(v)) throw new SolutionError("Non-finite numeric literal", s, expr);
      out.push({ type:"num", value:v, idx:s });
      prev = "num";
      continue;
    }

    // identifiers
    if (isA(ch)) {
      const s = i;
      i++;
      while (i < n && isAB(expr[i])) i++;
      out.push({ type:"id", value:expr.slice(s, i), idx:s });
      prev = "id";
      continue;
    }

    // parens
    if (ch === "(" || ch === ")") {
      out.push({ type:"paren", value:ch, idx:i });
      i++;
      prev = (ch === "(") ? "lparen" : "rparen";
      continue;
    }

    // operators
    if (ch==="+" || ch==="-" ||  ch==="*" || ch==="/" || ch==="^" ){
      const s = i;
      const unary = ((ch === "+" || ch === "-") && (prev === "START" || prev === "op" || prev === "lparen"));
      if (unary) {
        const sign = ch, next = expr[i+1] || "";
        // signed number
        if (isD(next) || (next === "." && isD(expr[i+2] || ""))) {
          i++;
          const ns = i;
          i = this.#readNum(expr, i);
          const v = Number(sign + expr.slice(ns, i));
          if (!Number.isFinite(v)) throw new SolutionError("Malformed signed number", s, expr);
          out.push({ type:"num", value:v, idx:s });
          prev = "num";
          continue;
        }
        // unary +/- before ( or id  => rewrite as 0 +/- <expr>
        if (next === "(" || /[A-Za-z_]/.test(next)) {
          out.push({ type:"num", value:0, idx:s });
          out.push({ type:"op", value:(sign === '-') ? '-' : '+', idx:s });
          i++;
          prev = "op";
          continue;
        }
        throw new SolutionError(`Dangling unary '${ch}'`, s, expr);
      }
      // binary operator
      out.push({ type:"op", value:ch, idx:s });
      i++;
      prev = "op";
      continue;
    }

    // otherwise
    throw new SolutionError(`+++Unexpected character '${ch}'`, i, expr);
  }

  // Turn id + '(' into func
  for (let k = 0; k < out.length - 1; k++) {
    if (out[k].type === "id" && out[k+1].type === "paren" && out[k+1].value === "(") {
      if (!this.functions.has(out[k].value)) {
        throw new SolutionError(`Unknown function '${out[k].value}'`, out[k].idx, expr);
      }
      out[k].type = "func";
    }
  }

  return out;
}
  #readNum(expr,i){
    const isD=c=>c>="0"&&c<="9"; let j=i; while(isD(expr[j])) j++;
    if (expr[j]==="."){ j++; while(isD(expr[j])) j++; }
    if (expr[j]==="e"||expr[j]==="E"){ j++; if (expr[j]==="+"||expr[j]==="-") j++; if (!isD(expr[j])) throw new SolutionError("Malformed exponent", j, expr); while(isD(expr[j])) j++; }
    return j;
  }
  #toRPN(tokens,expr){
    const out=[], st=[];
    for (const t of tokens){
      if (t.type==="num") { out.push(t); continue; }
      if (t.type==="id") { t.type="num"; t.value=Number(replacevars(t.value));out.push(t); continue;} //  throw new SolutionError(`Unknown identifier '${t.value}'`, t.idx, expr);
      if (t.type==="func"){ st.push(t); continue; }
      if (t.type==="op") {
        const p1=this.precedence[t.value]??-1, right=!!this.rightAssoc[t.value];
        while(st.length&&st[st.length-1].type==="op"){
          const p2=this.precedence[st[st.length-1].value]??-1;
          if ((right&&p1<p2)||(!right&&p1<=p2)) out.push(st.pop()); else break;
        }
        st.push(t); continue;
      }
      if (t.type==="paren" && t.value==="(") { st.push(t); continue; }
      if (t.type==="paren" && t.value===")") {
        let ok=false; while(st.length){ const top=st.pop(); if (top.type==="paren"&&top.value==="("){ ok=true; break; } out.push(top); }
        if (!ok) throw new SolutionError("Mismatched ')'", t.idx, expr);
        if (st.length && st[st.length-1].type==="func") out.push(st.pop()); continue;
      }
      throw new SolutionError(`Unknown token '${t.value}'`, t.idx, expr);
    }
    while(st.length){ const top=st.pop(); if (top.type==="paren") throw new SolutionError("Mismatched '('", top.idx, expr); out.push(top); }
    return out;
  }



  #evalRPN(rpn, expr){
    const st=[], need=(n,idx,what)=>{ if (st.length<n) throw new SolutionError(`Not enough operands for ${what}`, idx, expr); };
    for (const t of rpn){
      if (t.type==="num"){ st.push(t.value); continue; }
      if (t.type==="op"){
        need(2, t.idx, `'${t.value}'`);
        const b=st.pop(), a=st.pop();
        let v; switch(t.value){
          case "+": v=a+b; break;
          case "-": v=a-b; break;
          case "*": v=a*b; break;
          case "/": if (b===0) throw new SolutionError("Division by zero", t.idx, expr); v=a/b; break;
          case "^": v=Math.pow(a,b); break; default: throw new SolutionError(`Unknown operator '${t.value}'`, t.idx, expr);
        }
        if (!Number.isFinite(v)) throw new SolutionError(`Non-finite result v=${v}=${a} '${t.value}' ${b}`, t.idx, expr);
        st.push(v); continue;
      }
      if (t.type==="func"){
        need(1, t.idx, t.value); const x=st.pop();
        let v = (t.value==="sin") ? Math.sin(x) : Math.cos(x);
        if (!Number.isFinite(v)) throw new SolutionError(`Non-finite result for ${t.value}`, t.idx, expr);
        st.push(v); continue;
      }
      throw new SolutionError(`Bad RPN token '${t.value}'`, t.idx, expr);
    }
    if (st.length!==1) throw new SolutionError("Expression did not reduce to a single value");
    return st[0];
  }
}

/* ====================== Utilities ====================== */
function breakup(input, delimiter) {
  const out=[]; let s=String(input); let pos;
  while ((pos=s.indexOf(delimiter))!==-1) { out.push(s.substring(0,pos)); s=s.substring(pos+delimiter.length); }
  out.push(s); return out;
}
            </script>    
    
            <script>       
            // Grammar Lexer (keeps WS & NL) — MATH + strict '->', no RegExp anywhere
class GrammarLexer {
  constructor(text){
    this.src = String(text ?? "");
    this.tokens = [];
    this._lex();
  }

_push(type, value, line, col, lineStart){
  const lineEnd = this.src.indexOf("\n", lineStart);
  const sourceLine = this.src.slice(lineStart, lineEnd === -1 ? this.src.length : lineEnd);
  const start = lineStart + col;                 // absolute byte/char offset
  const end   = start + value.length;            // absolute end (exclusive)
  this.tokens.push({ type, value, line, col, sourceLine, start, end });
}

  // ===== Char helpers (no regex) =====
  _isSpace(c){ return c===" "||c==="\t"||c==="\r"||c==="\v"||c==="\f"; } // NOT \n
  _isDigit(c){ return c>="0" && c<="9"; }
  _isLetter(c){ return (c>="A"&&c<="Z")||(c>="a"&&c<="z")||c==="_"; }
  _isIdentC(c){ return this._isLetter(c)||this._isDigit(c); }

  // Unsigned number: 123 .5 1.23 1e+3 1.0E-2
  _readNumber(s, i, end){
    let j = i, has = false;
    while (j < end && this._isDigit(s[j])) { j++; has = true; }
    if (j < end && s[j] === "."){
      let k = j + 1, any = false;
      while (k < end && this._isDigit(s[k])) { k++; any = true; }
      if (any){ j = k; has = true; }
    }
    if (!has) return i;
    if (j < end && (s[j] === "e" || s[j] === "E")){
      let k = j + 1;
      if (k < end && (s[k] === "+" || s[k] === "-")) k++;
      let any = false;
      while (k < end && this._isDigit(s[k])) { k++; any = true; }
      if (!any) return i;
      j = k;
    }
    return j;
  }

  // Signed number (+/- optional)
  _readSignedNumber(s, i, end){
    let p = i;
    if (p < end && (s[p] === "+" || s[p] === "-")) p++;
    const j = this._readNumber(s, p, end);
    return (j > p) ? j : i;
  }

  // Identifier: optional & then optional +/- then [A-Za-z_][A-Za-z0-9_]*
  _readIdentifier(s, i, end){
    let j = i;
    if (j < end && s[j] === "&") j++;
    if (j < end && (s[j] === "+" || s[j] === "-")) j++;
    if (!(j < end && this._isLetter(s[j]))) return i;
    j++;
    while (j < end && this._isIdentC(s[j])) j++;
    return j;
  }





  // Self-contained MATH span (no spaces/newlines once begun)
  _matchMath(start){
    const s = this.src, len = s.length;
    let pos = start;

    const isSpace  = this._isSpace.bind(this);
    const isDigit  = this._isDigit.bind(this);
    const isLetter = this._isLetter.bind(this);
    const isIdentC = this._isIdentC.bind(this);
    const isOpOrPar = c => c==="("||c===")"||c==="+"||c==="-"||c==="*"||c==="/"||c==="^";

    // skip leading spaces before the span
    while (pos < len && isSpace(s[pos])) pos++;

 const mathStart = pos;                          // <-- real start (after spaces)


    let sawToken = false;
    let paren = 0;
    let hasBinaryOp = false;
    let hasFuncCall = false;
    let lastWasOperand = false; // number | identifier | ')'

    while (pos < len){
      const ch = s[pos];

      // hard stops
      if (ch === "\n" || ch === "#") break;

      // once started, any space ends the math span
      if (isSpace(ch)){
        if (!sawToken) { pos++; continue; } // before first token
        break;
      }

      const tStart = pos;

      // 1) operators / parens
      if (isOpOrPar(ch)){
        pos++; sawToken = true;

        if (ch === "("){ paren++; lastWasOperand = false; continue; }
        if (ch === ")"){
          if (paren === 0){ pos = tStart; break; }
          paren--; lastWasOperand = true; continue;
        }
        if (ch === "-"){
          const unary = !lastWasOperand;
          if (!unary) hasBinaryOp = true;
          lastWasOperand = false; continue;
        }
        // + * / ^ → binary iff preceded by operand
        if (lastWasOperand) hasBinaryOp = true;
        lastWasOperand = false; continue;
      }

      // 2) number (supports .5)
      if (isDigit(ch) || (ch === "." && isDigit(s[pos+1]||""))){
        const j = this._readNumber(s, pos, len);
        if (j > pos){ pos = j; sawToken = true; lastWasOperand = true; continue; }
      }

      // 3) identifier (var/func). No spaces allowed to func '('.
      if (isLetter(ch)){
        let j = pos + 1;
        while (j < len && isIdentC(s[j])) j++;
        const name = s.slice(pos, j);

        const isFunc = (name === "sin" || name === "cos"); // extend if needed
        const isVar  = (typeof findVariableForward === "function")
          ? (findVariableForward(name) !== -1) : true;

        if (!(isFunc || isVar)) break;

        if (isFunc){
          if (s[j] === "("){ hasFuncCall = true; }
          else { break; } // function must be immediately followed by '(' in span
        }

        pos = j; sawToken = true; lastWasOperand = true; continue;
      }

      // anything else ends the span
      break;
    }


 if (!sawToken) return null;
  const end = pos;
  const raw = s.slice(mathStart, end);           // <-- slice from mathStart

    // validity checks
    if (paren !== 0) return null;

    // reject pure signed number
    const isPureSignedNumber = (str)=>{
      let a = 0, b = str.length;
      while (a < b && isSpace(str[a])) a++;
      while (b > a && isSpace(str[b-1])) b--;
      if (a >= b) return false;
      let p = a;
      if (str[p] === "+" || str[p] === "-") p++;
      const q = this._readNumber(str, p, b);
      // if any space inside, earlier loop would have broken; here must be tight
      return (q > p && q === b);
    };
    if (isPureSignedNumber(raw)) return null;

    if (!lastWasOperand) return null;
    if (!(hasBinaryOp || hasFuncCall)) return null;


return { start: mathStart, end, text: raw };
  }

  // Strict '->' (no spaces inside). We DO NOT consume a following newline here,
  // because we now emit NL tokens explicitly.
  _matchArrow(i){
    const s = this.src;
    if (i + 1 < s.length && s[i] === "-" && s[i + 1] === ">"){
      return { end: i + 2 };
    }
    return null;
  }

  _lex(){
    const s = this.src;
    let i = 0, line = 1, col = 0, lineStart = 0;

    // single-char operators/delims outside MATH
    const singles = new Set(["(",")","[","]","{","}","|",";","*",",","/"]);

    while (i < s.length){
      const c = s[i];

      // --- Newline: emit NL, then advance line counters
      if (c === "\n"){
        this._push("NL", "\n", line, col, lineStart);
        i++; line++; col = 0; lineStart = i;
        continue;
      }

      // --- Whitespace run (no \n): keep WS
      if (this._isSpace(c)){
        let j = i + 1;
        while (j < s.length && this._isSpace(s[j]) && s[j] !== "\n") j++;
        this._push("WS", s.slice(i, j), line, col, lineStart);
        col += (j - i); i = j;
        continue;
      }

      // --- Comments
      if (c === "#"){ // shell to end of line
        const j = s.indexOf("\n", i);
        const end = j === -1 ? s.length : j;
        this._push("CMT", s.slice(i, end), line, col, lineStart);
        col += (end - i); i = end; continue;
      }
      if (c === "/" && s[i+1] === "/"){ // C++ line
        let j = i + 2;
        while (j < s.length && s[j] !== "\n") j++;
        this._push("CMT", s.slice(i, j), line, col, lineStart);
        col += (j - i); i = j; continue;
      }
  if (c === "/" && s[i+1] === "*"){ // C block
  let j = i + 2, closed = false;
  const l0 = line, c0 = col, ls0 = lineStart;  // <-- snapshot start-of-comment
  while (j < s.length){
    if (s[j] === "\n"){ line++; col = 0; lineStart = j + 1; }
    if (s[j] === "*" && s[j+1] === "/"){ j += 2; closed = true; break; }
    j++;
  }
  if (!closed){
    const lineEnd = s.indexOf("\n", lineStart);
    const errLine = s.slice(lineStart, lineEnd === -1 ? s.length : lineEnd);
    throw new ParseError("Unterminated block comment", l0, c0, ErrorReporter.caret(errLine, c0));
  }
  // value between i..j; but push with the *start* snapshot
  this._push("CMT", s.slice(i, j), l0, c0, ls0);
  i = j; col = i - lineStart; continue;
}

      // --- Arrow
      const arr = this._matchArrow(i);
      if (arr){
        this._push("OP", "->", line, col, lineStart);
        col += (arr.end - i); i = arr.end;
        // NOTE: a newline directly after '->' is fine; it'll be tokenized as NL on next loop
        continue;
      }

// --- MATH (before other tokens)
const math = this._matchMath(i);
if (math){
  // Advance col by (math.end - i) because i hasn’t moved yet
  this._push("MATH", math.text, line, col + (math.start - i), lineStart);
  col += (math.end - i);
  i = math.end;
  continue;
}


      // --- Single-char ops / delims (includes () [] {} and also comma for args)
      if (singles.has(c)){
        this._push("OP", c, line, col, lineStart);
        i++; col++; continue;
      }

      // --- Identifier
      {
        const end = this._readIdentifier(s, i, s.length);
        if (end > i){
          this._push("ID", s.slice(i, end), line, col, lineStart);
          col += (end - i); i = end; continue;
        }
      }

      // --- Number
      {
        const end = this._readSignedNumber(s, i, s.length);
        if (end > i){
          this._push("NUM", s.slice(i, end), line, col, lineStart);
          col += (end - i); i = end; continue;
        }
      }

      // --- Unexpected char
      const lineEnd = s.indexOf("\n", lineStart);
      const errLine = s.slice(lineStart, lineEnd === -1 ? s.length : lineEnd);
      throw new ParseError(`***Unexpected character '${c}'`, line, col, ErrorReporter.caret(errLine, col));
    }
  }
}


/* ==================================================== */

//                                                   Token Class

/* ===================================================== */
class Token {
  static fromToken(t){ const nt=new Token(t.token_name);
    nt.arguments=[...t.arguments]; nt.var_names=[...t.var_names];
    nt.var_name=t.var_name; nt.instance_type=t.instance_type;
    nt.instance_count=t.instance_count|0; nt.integer=!!t.integer; return nt;
  }
  constructor(name, instCount=0){
    this.token_name=name||""; this.arguments=[]; this.instance_type=""; this.instance_count=instCount|0;
    this.var_name=""; this.var_names=["","",""]; this.integer=false;
  }
  addArgument(v){ const n=+v; if (!Number.isFinite(n)) throw new RuntimeGrammarError(`Non-finite token argument for ${this.token_name}`); this.arguments.push(n); }
  addInstanceType(s){ this.instance_type=String(s); }
  isRule(){
    if (this.token_name!=="{" && this.token_name!=="}" && this.token_name!=="+" &&
        this.token_name!=="*" && this.token_name!=="[" && this.token_name!=="]" &&
        this.instance_type==="" && this.arguments.length===0) return this.token_name;
    return "";
  }
  setVarName(s) { this.var_name = String(s); }
  print(){
    const fmt=v=>{ let s=Number(v).toFixed(5); if (s.endsWith(".00000")) s=s.slice(0,-6); return s+" "; };
    let ss=(this.token_name==="R" && this.integer) ? "R* " : (this.token_name+" ");
    if (this.token_name==="[" || this.token_name==="]" || this.isRule()!=="") return ss;
    if (this.var_name) ss+=this.var_name+" ";
    ss+="( "; if (this.instance_type) ss+=this.instance_type+" ";
    ss+= (this.var_names[0] || fmt(this.arguments[0] ?? 0));
    ss+= (this.var_names[1] || fmt(this.arguments[1] ?? 0));
    if (this.arguments.length>2 || this.var_names[2]) ss+= (this.var_names[2] || fmt(this.arguments[2] ?? 0));
    ss+=") "; return ss;
  }
//======================================================

//                                         Perform Action
  /* ---------- Execute token against context + scene (now uses MathS2_js) ---------- */

//=======================================================
  performAction(context, scene, deps = {}) {
    const { addVariable = () => {} } = deps;
    const numArg = (i) => Number(this.arguments[i] ?? 0);
    const evalMaybe = (name, fallback) => (name ? Number(MathS2_js(name)) : Number(fallback));

    switch (this.token_name) {
     /* case "R": {
        addVariable(this.var_name, numArg(0), numArg(1), !!this.integer);
        addVariableInstance(this.var_name, numArg(0), numArg(1), !!this.integer);
        return;
      }*/
      case "S":
      case "DT":
      case "DS":
      case "T": {
        const s = context.getCurrentScope();
        const v = {
          x: evalMaybe(this.var_names[0], numArg(0)),
          y: evalMaybe(this.var_names[1], numArg(1)),
          z: evalMaybe(this.var_names[2], numArg(2)),
        };
        if (this.token_name === "S") s.S(v);
        else if (this.token_name === "DS") s.DS(v);
        else if (this.token_name === "DT") s.DT(v);
        else s.T(v);
        return;
      }
      case "A": {
        const s = context.getCurrentScope();
        const angle = evalMaybe(this.var_names[0], numArg(0));
        const axis  = (evalMaybe(this.var_names[1], numArg(1))|0);
        if (axis === 0) s.Rx(angle); else if (axis === 1) s.Ry(angle); else s.Rz(angle);
        return;
      }
      case "I": {
        const transform1 = context.getCurrentScope().getTransform();
        const transform2 = context.getCurrentScope().getTransform2();
        const transform3 = context.getCurrentScope().getTransform3();
        const _texIndex = this.var_names[0];

        const arg = (this.arguments.length > 1) ? (this.arguments[1] | 0) : 0;
        const val = (this.arguments.length > 2) ? Number(this.arguments[2]) : 0.125;
       

//////////////////////////////////////////////////////////
        scene.add(this.instance_type,transform1,transform2,transform3, _texIndex,arg, val);  ////////////SCENE
        

        return;
      }
      case "[": context.pushScope(); return;
      case "]": context.popScope();  return;
      case "{": context.newScope();  return;
      case "}": context.popScope();  return;
      default:  return; // rule name, no-op here
    }
  }
}
/* ======================================================= */

//                                    Rule Class

/* ======================================================= */
class Rule {
  constructor(name, repeat){
    this.rule_name=name; this.repeat=repeat; this.count=0;
    this.tokens=[]; this.section_tokens=[[],[],[]];
    this.var_name=""; this.var_names=Array.from({length:20},()=>"" );
    this.var_counter=0; this.probability=1.0; this.alternate=null;
  }
  addToken(tok, sec){
    if (!Array.isArray(this.section_tokens[sec])) this.section_tokens[sec]=[];
    this.section_tokens[sec].push(tok);
    if (sec===1) this.tokens.push(tok);
  }
  print(){
    let ss=this.rule_name+" ";
    ss+= (this.var_name!=="") ? (this.var_name+" ") : (this.repeat+" ");
    for (let i=0;i<this.var_counter;i++) if (this.var_names[i] !== "") ss+=this.var_names[i]+" ";
    if (this.probability<1.0) ss+= "; "+this.probability+" ";
    ss+="-> ";
    for (let k=0;k<3;k++){
      for (const t of this.section_tokens[k]) ss+=t.print();
      if (k===0 && this.section_tokens[0].length) ss+="| ";
      if (k===1 && this.section_tokens[2].length) ss+="| ";
    }
    if (this.alternate){
      ss+="-> ";
      for (const t of this.alternate.section_tokens[1]) ss+=t.print();
    }
    return ss;
  }
}
            </script>    
    
            <script>       
            //=====================================================


//                                                  Grammar Class


//====================================================


class Grammar {
  constructor(fileText){
    if (typeof fileText !== "string") throw new ParseError("Input must be a string");
    this.rule_list = [];
    this.tokens_new = [];

    // 1) Collapse physical lines into logical rule blocks
    const blocks = collectRuleBlocks(String(fileText));

    // 2) Parse each block: header -> body [-> alternate]
    for (let b = 0; b < blocks.length; b++) {
      const { header, body, alternate, line1 } = splitBlock(blocks[b]);

      // header: feed only up to and including the first '->'
      const stream = this.makeStream(header);

      const name = stream.nextVal();
      if (!name) throw new ParseError("Missing rule name", line1, 0, header);

      const rule = new Rule(name, 1);
      this.#ruleHeader(rule, stream, body, line1 - 1, header);

      if (alternate) this.#ruleAlternate(rule, alternate);

      this.rule_list.push(rule);
    }

    if (this.rule_list.length === 0) {
      throw new ParseError("No rules parsed. Ensure each rule starts with 'RuleName ->'");
    }

    this.tokens_new = this.Recurse(this.rule_list[0]);
  }



  #ruleAlternate(rule, s){
    rule.alternate=new Rule(rule.rule_name+"_Alt",1);
    rule.alternate.probability=Math.max(0, Math.min(1, 1.0 - rule.probability));
    this.ReadTokens(rule.alternate, s, 1);
  }

  #ruleHeader(rule, stream, body, idx, rawLine){
    let tok=stream.nextVal();
    if (tok === ";") {
      const p=stream.nextVal(); if (!this.isNumStr(p)) throw new ParseError("Expected probability after ';'", idx+1, 0, rawLine);
      rule.probability=parseFloat(p);
    } else {
      if (tok !== "->") { if (!this.isNumStr(tok)) rule.var_name=tok; else rule.repeat=parseInt(tok,10); }
      while (true){
        tok=stream.nextVal();
        if (tok===null || tok===";" || tok==="->") break;
        if (findVariableForward(tok)!==-1){ rule.var_names[rule.var_counter]=tok; rule.var_counter++; }
      }
      if (tok === ";") {
        const p=stream.nextVal(); if (!this.isNumStr(p)) throw new ParseError("Expected numeric probability after ';'", idx+1, 0, rawLine);
        rule.probability=parseFloat(p);
      }
    }

    const sections=breakup(body,"|");
    let n=sections.length; if (body.length && body[body.length-1]==="|") n--;
    if (n>3) throw new ParseError("At most 3 sections allowed (pre|main|post)", idx+1, 0, rawLine);
    if (n===1) this.ReadTokens(rule, body, 1); else for (let i=0;i<n;i++) this.ReadTokens(rule, sections[i], i);
  }

//========================================================

//                                Read Tokens

//========================================================


 ReadTokens(rule, rule_str, sec){
  const L = new GrammarLexer(rule_str);
  const S = this.makeStreamFromLexer(L);

  // --- log (unchanged) ---
  const log = (...a) => {
    const msg = `[MATH] ${a.join(" ")}`;
    const out = (typeof document !== "undefined") && document.getElementById && document.getElementById("out");
    if (out){ out.textContent += "\n" + msg; out.scrollTop = out.scrollHeight; }
    else if (typeof console !== "undefined" && console.debug){ console.debug(msg); }
  };

  // === NEW: helpers to ignore WS/CMT/NL ===
  const IGN = new Set(["WS","CMT","NL"]);

  const eatIgnorable = () => {
    let pk = S.peekTok?.();
    while (pk && IGN.has(pk.type)) { S.nextTok(); pk = S.peekTok?.(); }
  };

  const nextLoose = (msgIfEOF = "Unexpected end of input") => {
    eatIgnorable();
    const t = S.nextTok();
    if (!t) throw new ParseError(msgIfEOF, 0, 0, "");
    if (IGN.has(t.type)) return nextLoose(msgIfEOF); // safety (shouldn’t hit due to eatIgnorable)
    return t;
  };

  const peekLoose = () => {
    eatIgnorable();
    return S.peekTok?.();
  };

  const expectOpLoose = (ch, ctx = "syntax") => {
    eatIgnorable();
    const t = S.nextTokReq?.(`${ctx} expected '${ch}'`) ?? nextLoose(`${ctx} expected '${ch}'`);
    if (t.type !== "OP" || t.value !== ch) {
      throw ErrorReporter.fromToken(`${ctx} expected '${ch}'`, t);
    }
    return t;
  };


  try {
    while (true){
      const t = peekLoose();            // look at next significant token
      if (!t) break;
      S.nextTok();                      // consume it (we already ate ignorable)

      // ===== skip handled above, kept here for clarity =====
      // if (t.type==="WS" || t.type==="CMT" || t.type==="NL") continue;

      // --- S / T / DS / DT ---
      if (t.type==="ID" && (t.value==="S"||t.value==="T"||t.value==="DS"||t.value==="DT")){
        const name = t.value;
        expectOpLoose("(", name);
        const tok = new Token(name);

        for (let i=0; i<3; i++){
          const a = nextLoose(`${name} missing argument ${i}`);
          if (a.type==="NUM") {
            tok.addArgument(parseFloat(a.value));
          } else if (a.type==="ID") {
            tok.var_names[i] = a.value; tok.addArgument(0);
          } else if (a.type==="MATH") {
            const arg = parseFloat(MathS2_js(a.value));
            tok.addArgument(arg);
          } else {
            throw ErrorReporter.fromToken(`${name}: argument ${i} must be number or identifier`, a);
          }
        }
        expectOpLoose(")", name);
        rule.addToken(tok, sec);
        continue;
      }

      // --- R / R* ---
      if (t.type==="ID" && (t.value==="R" || t.value==="R*")){
        const tok = new Token("R");
        let integer = (t.value==="R*");
        if (!integer){
          const pk = peekLoose();
          if (pk && pk.type==="OP" && pk.value==="*") { S.nextTok(); integer = true; }
        }
        tok.integer = integer;

        const nameTok = nextLoose(integer?"R* expects a variable name":"R expects a variable name");
        if (nameTok.type!=="ID" || !/^[A-Za-z_][A-Za-z0-9_]*$/.test(nameTok.value)){
          throw ErrorReporter.fromToken(integer?"R* expects a variable name":"R expects a variable name", nameTok);
        }
        tok.var_name = nameTok.value;

        expectOpLoose("(", "R");
        const lowTok  = nextLoose("R lower bound");
        const highTok = nextLoose("R upper bound");
        if (lowTok.type!=="NUM" || highTok.type!=="NUM") {
          throw ErrorReporter.fromToken("R bounds must be numeric and space-delimited",
            lowTok.type!=="NUM" ? lowTok : highTok);
        }
        tok.addArgument(parseFloat(lowTok.value));
        tok.addArgument(parseFloat(highTok.value));
        expectOpLoose(")","R");

        const low  = parseFloat(lowTok.value);
        const high = parseFloat(highTok.value);
        // add variable (your hooks)
        addVariable(tok.var_name, low, high, integer);
        addVariableInstance(tok.var_name, low, high, integer);

        rule.addToken(tok, sec);
        continue;
      }

      // --- I (instances) ---
      if (t.type==="ID" && t.value==="I"){
        expectOpLoose("(", "I");
        const typTok = nextLoose("I instance type");
        const allowed = new Set(["Cube","Sphere","Cylinder","CubeX","CubeY"]);
        if (typTok.type!=="ID" || !allowed.has(typTok.value)){
          throw ErrorReporter.fromToken("I unknown instance type", typTok);
        }
        const tok = new Token("I");
        tok.addInstanceType(typTok.value);

        let pk = peekLoose();
        if (pk && !(pk.type==="OP" && pk.value===")")){
          const a1 = nextLoose("I first argument");
          if (a1.type==="NUM") {
            tok.var_names[0] = "concrete"; // (kept from your logic)
          } else if (a1.type==="ID") {
            tok.var_names[0] = a1.value; tok.addArgument(0);
          } else {
            throw ErrorReporter.fromToken("I: first argument must be number or identifier", a1);
          }

          pk = peekLoose();
          if (pk && !(pk.type==="OP" && pk.value===")")){
            const a2 = nextLoose("I second argument");
            if (a2.type!=="NUM") throw ErrorReporter.fromToken("I: second argument must be numeric (space-delimited)", a2);
            tok.addArgument(parseFloat(a2.value));

            pk = peekLoose();
            if (pk && !(pk.type==="OP" && pk.value===")")){
              const a3 = nextLoose("I third argument");
              if (a3.type!=="NUM") throw ErrorReporter.fromToken("I: third argument must be numeric (space-delimited)", a3);
              tok.addArgument(parseFloat(a3.value));
            }
          }
        }
        expectOpLoose(")","I");
        rule.addToken(tok, sec);
        continue;
      }

      // --- A (angle) ---
      if (t.type==="ID" && t.value==="A"){
        expectOpLoose("(", "A");
        const tok = new Token("A");
        for (let i=0; i<2; i++){
          const a = nextLoose(`A missing argument ${i}`);
          if (a.type==="NUM") {
            tok.addArgument(parseFloat(a.value));
          } else if (a.type==="ID") {
            tok.var_names[i] = a.value; tok.addArgument(0);
          } else if (a.type==="MATH") {
            tok.var_names[i] = a.value; tok.addArgument(0);
          } else {
            throw ErrorReporter.fromToken(`A: argument ${i} must be number or identifier ${a.type} ${a.value}`, a);
          }
        }
        expectOpLoose(")","A");
        rule.addToken(tok, sec);
        continue;
      }

      // --- structural tokens ---
      if (t.type==="OP" && (t.value==="[" || t.value==="]")) {
        rule.addToken(new Token(t.value), sec); continue;
      }
      if (t.type==="OP" && (t.value==="{" || t.value==="}" || t.value==="*")) {
        continue; // ignore here per your original behavior
      }

      // --- bare identifiers become tokens (rule refs, etc.) ---
      if (t.type==="ID") { rule.addToken(new Token(t.value), sec); continue; }

      // Anything else: error
      throw ErrorReporter.fromToken("Unknown/unsupported token in rule", t);
    }
  } catch(e){
    errorout(e);
    if (e instanceof ParseError) throw e;
    throw new ParseError(`Tokenization/Read error: ${e.message||e}`, 0, 0, "");
  }
}

// unify MathS to match MathS2_js behavior
  MathS(input){ return String(MathS2_js(input)); }


//================================================
//                Late-binding argument resolver
//===============================================
update_token = (tok) => {
  // Defensive normalization (older Token impls)
  tok.arguments = Array.isArray(tok.arguments) ? tok.arguments : [];
  tok.var_names = Array.isArray(tok.var_names) ? tok.var_names : [];

  const tryEval = (expr) => {
    if (!expr) return null;
    try {
      const v = MathS2_js(expr);
      return Number.isFinite(v) ? v : null;
    } catch { return null; }
  };
  const fill = (i) => {
    const expr = tok.var_names[i];
    if (!expr) return;
    const n = tryEval(expr);
    if (n !== null) {
      tok.arguments[i] = n;
      tok.var_names[i] = "";
    } else if (typeof tok.arguments[i] !== "number") {
      tok.arguments[i] = 0; // keep a numeric slot for executors
    }
  };

  switch (tok.token_name) {
    case "S":
    case "T":
    case "DS":
    case "DT":
      fill(0); fill(1); fill(2);
      break;
    case "A":
      fill(0); fill(1);
      break;
    case "I":
     // fill(0);            // only first is late-bindable in your format
      break;
    default:
      // no-op
      break;
  }
};


// ===============================================
//                   Recurse Rules
// ===============================================
Recurse(rule){
  const out = [];

  // make per-call instances for rule variables
  for (let i = 0; i < rule.var_counter; i++) {
    addVariableInstance(rule.var_names[i]);
  }

  // resolve repeat if rule.var_name is a math expr/symbol
  if (rule.var_name !== "") {
    const v = parseFloat(this.MathS(rule.var_name));
    if (!Number.isFinite(v)) {
      throw new RuntimeGrammarError(`Repeat not finite for rule ${rule.rule_name}`);
    }
    rule.repeat = v;
  }
  if (!Number.isFinite(rule.repeat) || rule.repeat < 0) {
    throw new RuntimeGrammarError(`Bad repeat count for ${rule.rule_name}`);
  }

  // choose main vs alternate using probability
  if (rule.alternate) {
    const roll = RNG.random();
    if (roll >= rule.probability) {
      const more = this.Recurse(rule.alternate);
      for (const t of more) { this.update_token(t); out.push(t); }
      // clean up vars before returning
      for (let i = 0; i < rule.var_counter; i++) removeVariable(rule.var_names[i]);
      return out;
    }
  }

  const runSection = (tokens) => {
    for (const tt of tokens) {
      const ruleName = tt.isRule?.() || "";
      if (ruleName) {
        const idx = this.findRule(ruleName);
        if (idx !== -1) {
          const more = this.Recurse(this.rule_list[idx]);
          for (const t of more) { this.update_token(t); out.push(t); }
        } else {
          throw new RuntimeGrammarError(`Unknown rule referenced: ${ruleName}`);
        }
      } else {
        const cc = Token.fromToken(tt);
        this.update_token(cc);
        out.push(cc);
      }
    }
  };

  // sections: 0 | 1 | 2 (sec 1 repeats)
  for (let sec = 0; sec < 3; sec++) {
    if (sec === 1) {
      const varCount = new Variable(rule.rule_name + "_count", 0, 0, true);
      variable_list.push(varCount);
      for (let l = 0; l < rule.repeat; l++) {
        varCount.value = l;
        runSection(rule.section_tokens[sec]);
      }
      removeVariable(rule.rule_name + "_count");
    } else {
      runSection(rule.section_tokens[sec]);
    }
  }

  // cleanup
  for (let i = 0; i < rule.var_counter; i++) removeVariable(rule.var_names[i]);
  return out;
}

findRule(name){
  for (let i = 0; i < this.rule_list.length; i++) {
    if (this.rule_list[i].rule_name === name) return i;
  }
  return -1;
}

makeStream(header){
  const L = new GrammarLexer(header);
  return this.makeStreamFromLexer(L);
}

// Stream that **skips WS/CMT/NL** and works with either token list or pull-mode lexer
makeStreamFromLexer(L){
  // Build a flat array of tokens defensively
  let toks = [];
  if (Array.isArray(L.tokens)) {
    toks = L.tokens;
  } else if (typeof L.nextTok === "function") {
    let t; while ((t = L.nextTok())) toks.push(t);
  }

  let i = 0;
  const IGN = new Set(["WS","CMT","NL"]);

  const skip = () => {
    while (i < toks.length && IGN.has(toks[i].type)) i++;
  };

  const peekTok = () => {
    let j = i;
    while (j < toks.length && IGN.has(toks[j].type)) j++;
    return j < toks.length ? toks[j] : null;
  };

  const nextTok = () => {
    skip();
    return i < toks.length ? toks[i++] : null;
  };

  const nextTokReq = (msg = "Unexpected end of input") => {
    skip();
    const t = i < toks.length ? toks[i++] : null;
    if (!t) throw new ParseError(msg, 0, 0, "");
    return t;
  };

  const nextVal = () => {
    skip();
    return i < toks.length ? toks[i++].value : null;
  };

  return { peekTok, nextTok, nextTokReq, nextVal };
}

// Expect a specific OP (skips ignorable; better error context)
expectOp(S, op, ctx = "syntax"){
  const t = S.nextTok();
  if (!t || t.type !== "OP" || t.value !== op) {
    if (t) throw ErrorReporter.fromToken(`${ctx} expects '${op}'`, t);
    throw new ParseError(`${ctx} expects '${op}'`, 0, 0, "");
  }
}

isNumStr(s){
  return typeof s === "string" &&
    /^[-+]?(?:\d+(?:\.\d+)?|\.\d+)(?:[eE][-+]?\d+)?$/.test(s);
}
}
            </script>    
    
            <script>       
            // Collect logical blocks///////////--------------
//---that start with: ^\s*<RuleName>\b ... ->  (first arrow on the line)
// A new block begins when a line looks like a rule head.
//
function collectRuleBlocks(src){
  const lines = src.split(/\r?\n/);
  const blocks = [];
  let cur = [];
  let curStartLine = 1;

  const isHead = (line) => /^\s*[A-Za-z_]\w*\b.*->/.test(line);

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (isHead(line)) {
      if (cur.length) blocks.push({ text: cur.join("\n"), line1: curStartLine });
      cur = [line];
      curStartLine = i + 1;
    } else {
      // Continuation (blank/comment/anything) belongs to current block
      if (!cur.length) { // file may start with non-head; skip cleanly
        continue;
      }
      cur.push(line);
    }
  }
  if (cur.length) blocks.push({ text: cur.join("\n"), line1: curStartLine });
  return blocks;
}

// Split a logical 
//--block into: header(with first ->), body, and optional 
//--alternate(after second ->)
function splitBlock(block){
  const text = typeof block === "string" ? block : block.text;
  const line1 = typeof block === "string" ? 1 : block.line1;

  const first = text.indexOf("->");
  if (first === -1) throw new ParseError("Rule head missing '->'", line1, 0, text);

  const header = text.slice(0, first + 2);      // include '->'
  const rest   = text.slice(first + 2);

  const second = rest.indexOf("->");            // optional alternate
  const body   = (second === -1 ? rest : rest.slice(0, second)).trim();
  const alternate = (second === -1 ? ""   : rest.slice(second + 2).trim());

  return { header, body, alternate, line1 };
}
//------------------------------------------------------------------------
/*  EXECUTION PIPE: prepare() ====================== */
function prepare(tokens,scene) {
  const ctx = new Context();
  
  const deps = { addVariable };
 // MathS2_js is called directly inside performAction

  for (const t of tokens) t.performAction(ctx, scene, deps);
  return { ctx, scene };
}
            </script>    
    
            <script>       
            /* Pretty printers ====================== */
function formatMat4(m){
  const r = (a,b,c,d)=>`${a.toFixed(3)} ${b.toFixed(3)} ${c.toFixed(3)} ${d.toFixed(3)}`;
  return [
    r(m[0], m[4], m[8],  m[12]),
    r(m[1], m[5], m[9],  m[13]),
    r(m[2], m[6], m[10], m[14]),
    r(m[3], m[7], m[11], m[15]),
  ].join("\n");
}
function printScene(scene){
  const items = scene.getAll();
  if (!items.length) return "(scene empty)";
  let out = `Scene items: ${items.length}\n`;
  for (let i=0;i<items.length;i++){
    const it = items[i];
    out += `\n#${i} arg=${it.arg} val=${it.val}\n${formatMat4(it.transform)}\n`;
  }
  return out;
}
            </script>    
    
            <script>       
            /* = Integrated Editor + Renderer + Tutorial (with DOM console) ================== */
(function () {
  'use strict';

  /* ---------- Safe DOM getters ---------- */
  const need = (id) => {
    const el = document.getElementById(id);
    if (!el){ console.warn("[UI] Missing element #${id}");return;}
   return el;
  };

  /* ---------- Grab UI ---------- */
  const src           = need('src');
  const hl            = need('hl');
  const codewrap      = need('codewrap');
  const wrapBtn       = need('wrapBtn');

  const out           = need('out');           // console panel (DOM rendered)
  const goBtn         = need('go');
  const clrBtn        = need('clr');
  const statusEl      = need('status');
  const orbitToggle   = need('orbitToggle');

  const refDock       = need('refDock');
  const refHead       = need('refHead');
  const refToggleLabel= need('refToggleLabel');

  /* ---------- Console helpers (DOM-rendered) ---------- */
  function setStatus(msg){ if (statusEl) statusEl.textContent = msg; }

  function renderConsoleLine(kind, text) {
    if (!out){console.error("out not found.exiting."); return;}
    const line = document.createElement('div');
    line.className = `console-line console-${kind}`;

    const time = document.createElement('span');
    time.className = 'console-time';
    time.textContent = `[${new Date().toLocaleTimeString()}]`;

    const msg = document.createElement('span');
    msg.className = 'console-msg';
    msg.textContent = String(text);

    line.appendChild(time);
    line.appendChild(msg);
    out.appendChild(line);
    out.scrollTop = out.scrollHeight;
  }

  const info  = (t)=> renderConsoleLine('info',  t);
  const warn  = (t)=> renderConsoleLine('warn',  t);
  const error = (t)=> renderConsoleLine('error', t);

  /* ---------- Scene & Renderer ---------- */
  let scene, renderer;
  
    if (typeof Scene !== 'function' || typeof WebGLSceneRenderer !== 'function') {
      error('[Renderer] Scene or WebGLSceneRenderer is not loaded globally.');
      return;
    }
    try {
      scene = new Scene();
      renderer = new WebGLSceneRenderer('#glcanvas', { wireframe: true });
      renderer.setScene(scene);
      info('Renderer initialised.');
    } catch (err) {
      error("[Renderer] Failed to initialize.");
    }
 

  /* ---------- Output header helper (kept) ---------- */
  const TUTORIAL_NAME = 'Visual Grammar 101';
  function updateOutHeader(stepIndex, total, title, done=false){
    // Keep the first line of console reflecting tutorial status as an info line
    renderConsoleLine('info',
      `Tutorial: ${TUTORIAL_NAME} — Step ${Math.min(stepIndex,total)}/${total}${title ? ` (${title})` : ''}${done ? ' • ✅ Completed' : ''}`
    );
  }

  /* ---------- Word Wrap toggle ---------- */
  let wrapOn = false;
  function setWrap(on){
    wrapOn = !!on;
    codewrap && codewrap.classList.toggle('wrap-on', wrapOn);
    if (wrapBtn) wrapBtn.textContent = wrapOn ? '⤶ Wrap: On' : '⤶ Wrap: Off';
    updateHighlight();
  }
  wrapBtn && wrapBtn.addEventListener('click', ()=> setWrap(!wrapOn));

  /* ---------- Highlighter ---------- */
  // simple hue by name
  function nameHue(name){ let h=0; for (let i=0;i<name.length;i++) h=(h*31 + name.charCodeAt(i))>>>0; return h%360; }
  const ctxStyle = (name, a=0.18) => `style="background:hsla(${nameHue(name)},70%,20%,${a});"`;

  const TOK_RE = /(\bR\*?\b|\bA\b|\bS\b|\bT\b|\bDS|\bDT\b|\bI\b|->|\[|\]|\{|\}|\||\(|\)|-?\d+(?:\.\d+)?|[A-Za-z_]\w*|\s+|.)/g;
  const esc = (s)=> s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));

  function collectSymbols(text){
    const varNames = new Set();
    const ruleNames = new Set();
    const reR = /(^|\s)R\*?\s+([A-Za-z_]\w*)/g;
    let m; while ((m = reR.exec(text))) varNames.add(m[2]);
    const reRule = /^([A-Za-z_]\w*)\s.*?->/gm;
    while ((m = reRule.exec(text))) ruleNames.add(m[1]);
    return { varNames, ruleNames };
  }

  function highlightToHTML(text){
    const { varNames, ruleNames } = collectSymbols(text || '');
    let html = '', m;
    while ((m = TOK_RE.exec(text || ''))){
      const tok = m[0];
      if (/^\s+$/.test(tok)) { html += tok.replace(/ /g,'&nbsp;').replace(/\n/g,'<br>'); continue; }
      if (/^(R\*?|A|S|T|D|I)$/.test(tok))      html += `<span class="tok-kw">${tok}</span>`;
      else if (tok === '->' || tok === '|')    html += `<span class="tok-op">${tok}</span>`;
      else if (tok === '(' || tok === ')')     html += `<span class="tok-paren">${tok}</span>`;
      else if (tok === '[' || tok === ']' || tok === '{' || tok === '}')
                                               html += `<span class="tok-brack">${tok}</span>`;
      else if (/^-?\d+(?:\.\d+)?$/.test(tok))  html += `<span class="tok-num">${tok}</span>`;
      else if (/^[A-Za-z_]\w*$/.test(tok)){
        if (varNames.has(tok))      html += `<span class="ctx tok-var" ${ctxStyle(tok,0.18)}>${tok}</span>`;
        else if (ruleNames.has(tok))html += `<span class="ctx tok-rule" ${ctxStyle(tok,0.14)}>${tok}</span>`;
        else                        html += esc(tok);
      } else html += esc(tok);
    }
    return html;
  }

  let hlRAF = null;
  function updateHighlight(){
    if (!hl || !src) return;
    if (hlRAF) cancelAnimationFrame(hlRAF);
    hlRAF = requestAnimationFrame(()=> {
      hl.innerHTML = highlightToHTML(src.value || '');
      hlRAF = null;
    });
  }
  src && src.addEventListener('input', updateHighlight);
  src && src.addEventListener('scroll', ()=> { if (hl && src){ hl.scrollTop = src.scrollTop; hl.scrollLeft = src.scrollLeft; } });

  /* ---------- Collapsible Mini‑Reference ---------- */
  refHead && refHead.addEventListener('click', () => {
    if (!refDock) return;
    refDock.classList.toggle('min');
    const open = !refDock.classList.contains('min');
    if (refToggleLabel) refToggleLabel.textContent = open ? 'Hide ▲' : 'Show ▼';
  });

  /* ---------- Grammar pipeline with logging ---------- */
  function runGrammarPipeline(text) {
    if (!scene || !renderer) {
      setStatus('Renderer not ready.');
      warn('[Pipeline] Renderer not ready.');
      return;
    }
    if (!text) {
      setStatus('Nothing to run.');
      warn('Nothing to run — the editor is empty.');
      return;
    }
    try {
      scene.clear?.();
      if (typeof Grammar !== 'function' || typeof prepare !== 'function') {
        throw new Error('Grammar/prepare not available globally.');
      }
      const g = new Grammar(text);
      info(`Tokenising… (${g.tokens_new?.length ?? 'unknown'} tokens)`);
      prepare(g.tokens_new, scene);
      renderer.setScene?.(scene);
      renderer.invalidate?.();
      setStatus('Done.');
      info(`Build complete. Scene items: ${scene.getAll?.().length ?? 'n/a'}`);
    } catch (e) {
      setStatus('Error.');
      error(`Grammar error: ${e?.message || e}`);
      // If you can detect error ranges, call flashErrorRange(start, end)
    }
  }

  /* ---------- Actions: Run / Clear (logs + status) ---------- */
  goBtn && goBtn.addEventListener('click', () => {
    if (!src) return;
    const text = (src.value || '').trim();
    if (!text){
      setStatus('Nothing to run.');
      warn('Nothing to run — the editor is empty.');
      return;
    }
    setStatus('Running…');
    info('Parsing grammar and preparing scene…');
    runGrammarPipeline(text);
  });

  clrBtn && clrBtn.addEventListener('click', () => {
    if (!src) return;
    src.value = '';
    updateHighlight();
    setStatus('Cleared.');
    info('Editor cleared.');
    scene && scene.clear?.();
    renderer && renderer.setScene?.(scene);
    src.focus();
  });

  /* ---------- Very slow auto‑orbit (play/pause) ---------- */
  let orbitOn = false, orbitHandle = null;
  function orbitLoop(){
    if (!orbitOn || !renderer) return;
    try {
      renderer.theta = (renderer.theta || 0) + 0.0025;
      renderer.invalidate?.();
    } catch(e){ warn('[Orbit] invalidate failed: ' + (e?.message || e)); }
    orbitHandle = requestAnimationFrame(orbitLoop);
  }
  orbitToggle && orbitToggle.addEventListener('click', ()=>{
    orbitOn = !orbitOn;
    orbitToggle.textContent = orbitOn ? '⏸ Auto Orbit' : '▶ Auto Orbit';
    if (orbitOn){ orbitLoop(); } else { if (orbitHandle) cancelAnimationFrame(orbitHandle); orbitHandle=null; }
  });

  /* ---------- Tutorial (kept lightweight; logs into console header) ---------- */
  const P1 = `X -> R len ( 0.15 0.3 ) `;
  const P2 = `R radius ( 0.75 1.75 ) `;
  const P3 = `R* count ( 21 63 ) `;
  const P4 = `A ( 90 0 ) `;
  const P5 = `S ( 1 1 10 ) [ Y ]\n\n`;
  const P6 = `Y 19 len count radius ->  A ( 19 2 )  [ YB ]\n`;
  const P7 = `YB -> T ( -radius 0 0 ) | [ YB1 ] [ YB2 ]\n\n`;
  const P8 = `YB1 ->  S ( radius len 1 ) DS ( 1 0.03 1 )  I ( CubeX 2 0 1 )\n`;
  const P9 = `YB2 ->  A ( 180 0 )  S ( radius len 1 ) DS ( 1 0.03 1 )  I ( CubeX 2 0 1 )`;
  const DEMO = [P1,P2,P3,P4,P5,P6,P7,P8,P9];

  function initTutorial(){
    // If overlay not present, preload editor and log
    const overlay = document.getElementById('tut');
    if (!overlay){
      info('[Tutorial] Overlay UI not present; loading demo grammar into editor.');
      if (src){ src.value = DEMO.join(''); updateHighlight(); }
      updateOutHeader(0, DEMO.length, 'Simple Mode');
      return;
    }
    // Otherwise your existing tutorial engine can run here.
    updateOutHeader(0, DEMO.length, 'Ready');
}
/* ---------- Tutorial Start Button ---------- */
function addTutorialBtn() {
  const bar = document.getElementById("toolbar") || document.body;
  if (!bar) return;
  if (document.getElementById("tutorialBtn")) return; // prevent dupes

  const btn = document.createElement("button");
  btn.id = "tutorialBtn";
  btn.className = "btn secondary";
  btn.textContent = "▶ Start Tutorial";
 
 btn.addEventListener("click", () => {
  initTutorial();
  bar.appendChild(btn);
  });


}

addTutorialBtn();

})();
            </script>    
    
            <script>       
            /* Smart Editor v0.4 — syntax errors + active/reachable rule highlighting */
(() => {
  'use strict';

const GRAMMAR_TOOLTIPS = {
  A:  "Rotate → A (angle, axis)\nAngle in degrees; axis 0=x, 1=y, 2=z",
  T:  "Translate → T (x, y, z)\nMove along X, Y, Z",
  S:  "Scale → S (x, y, z)\nScale factors on X, Y, Z",
  DS: "Dimensional Scale → DS (x, y, z)\nPer-dimension scale with offset semantics",
  DT: "Delta Translate → DT (x, y, z)\nIncremental translation",
  I:  "Instantiate → I (type, tex?, tex_scale?)\nTypes: Cube, CubeX, CubeY …",
  R:  "Procedural Variable → R (min, max)\nUse R* for integer range"
};
  // ----- one-time guard -----
  const wrap = document.getElementById('codewrap');
  if (!wrap || wrap.dataset.seInit === '1') return;
  wrap.dataset.seInit = '1';

  // ----- UI -----
  const $ = (id) => document.getElementById(id);
  const ui = {
    src: $('src'),
    hl: $('hl'),
    hit: $('se-hit'),
    hitPre: $('se-hit-pre'),
    tip: $('se-tooltip'),
    wrapBtn: $('wrapBtn'),
    out: $('out'),
  };
  if (!ui.src || !ui.hl || !ui.hit || !ui.hitPre || !ui.tip) {
    console.error('[SmartEditor] Missing #src/#hl/#se-hit/#se-hit-pre/#se-tooltip');
    return;
  }

  // ----- utils -----
  const esc = (s) => s.replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));
  const log = (m) => { if (ui.out) { ui.out.textContent += `\n${m}`; ui.out.scrollTop = ui.out.scrollHeight; } };

  // ----- metrics cloning (both layers) -----
  const METRIC_PROPS = [
    'font-family','font-size','font-weight','font-style','line-height','letter-spacing',
    'tab-size','text-rendering','-webkit-font-smoothing','font-variant-ligatures','font-kerning',
    'font-feature-settings','font-synthesis-weight','font-synthesis-style',
    'padding-top','padding-right','padding-bottom','padding-left',
    'border-top-width','border-right-width','border-bottom-width','border-left-width',
    'box-sizing','white-space','overflow-wrap','word-break'
  ];
  function cloneMetrics() {
    const cs = getComputedStyle(ui.src);
    for (const p of METRIC_PROPS) {
      const v = cs.getPropertyValue(p);
      ui.hl.style.setProperty(p, v);
      ui.hitPre.style.setProperty(p, v);
    }
    const w = ui.src.clientWidth, h = ui.src.clientHeight;
    ui.hl.style.width = w + 'px';  ui.hl.style.height = h + 'px';
    ui.hitPre.style.width = w + 'px'; ui.hitPre.style.height = h + 'px';
  }

  // ----- tokenizer / symbol collection -----
  const TOK_RE = /(\bR\*?\b|\bA\b|\bS\b|\bT\b|\bD\b|\bI\b|->|\||\{|\}|\[|\]|\(|\)|-?\d+(?:\.\d+)?|[A-Za-z_]\w*|\s+|.)/g;
  function tokenize(text) {
    TOK_RE.lastIndex = 0;
    const out = []; let m, i = 0, pos = 0;
    while ((m = TOK_RE.exec(text))) {
      const raw = m[0];
      let type = 'sym';
      if (/^\s+$/.test(raw)) type = 'ws';
      else if (/^(R\*?|A|S|T|D|I)$/.test(raw)) type = 'kw';
      else if (raw === '->' || raw === '|') type = 'op';
      else if (raw === '(' || raw === ')') type = 'par';
      else if (raw === '{' || raw === '}' || raw === '[' || raw === ']') type = 'br';
      else if (/^-?\d+(?:\.\d+)?$/.test(raw)) type = 'num';
      else if (/^[A-Za-z_]\w*$/.test(raw)) type = 'id';
      out.push({ i: i++, type, raw, start: pos, end: pos + raw.length });
      pos += raw.length;
    }
    return out;
  }

  function collectSymbols(text) {
    const vars = new Set(), rules = new Set(); let m;
    const reR = /(^|\s)R\*?\s+([A-Za-z_]\w*)/g;
    while ((m = reR.exec(text))) vars.add(m[2]);
    const reRule = /(^|\n)\s*([A-Za-z_]\w*)\s.*?->/g;
    while ((m = reRule.exec(text))) rules.add(m[2]);
    return { vars, rules };
  }

  // ----- rule indexing + graph (defs, refs, active, reachable) -----
  function buildRuleIndex(text, tokens, ruleNames) {
    // Find each rule head token (id whose line contains '->' before newline)
    const heads = [];
    for (let k = 0; k < tokens.length; k++) {
      const t = tokens[k];
      if (t.type !== 'id' || !ruleNames.has(t.raw)) continue;

      const lineEnd = text.indexOf('\n', t.end);
      const arrowPos = text.indexOf('->', t.end);
      if (arrowPos !== -1 && (lineEnd === -1 || arrowPos < lineEnd)) {
        heads.push({ name: t.raw, k, arrowPos });
      }
    }
    // Determine body ranges and map name -> rule info
    const rules = [];
    for (let idx = 0; idx < heads.length; idx++) {
      const head = heads[idx];
      const nextHeadTok = heads[idx + 1]?.k;
      // body starts after '->' (allow newline directly after)
      let bodyStart = head.arrowPos + 2;
      if (text[bodyStart] === '\n') bodyStart++;
      let bodyEnd = text.length;
      if (nextHeadTok != null) {
        bodyEnd = tokens[nextHeadTok].start; // start of next head id
      }
      rules.push({
        name: head.name,
        defIndex: head.k,         // token index of definition id
        bodyStart,
        bodyEnd,
        refs: new Set(),
      });
    }
    const byName = new Map(rules.map(r => [r.name, r]));
    // Collect references inside bodies
    for (const r of rules) {
      for (const t of tokens) {
        if (t.start < r.bodyStart || t.start >= r.bodyEnd) continue;
        if (t.type === 'id' && ruleNames.has(t.raw) && t.i !== byName.get(t.raw)?.defIndex) {
          r.refs.add(t.raw);
        }
      }
    }
    return { list: rules, byName };
  }

  function caretActiveRule(text, tokens, ruleIdx, caret) {
    for (const r of ruleIdx.list) {
      const headStart = tokens[r.defIndex].start;
      const headEnd   = text.indexOf('\n', headStart) === -1 ? text.length : text.indexOf('\n', headStart);
      const inHead = caret >= headStart && caret <= headEnd;
      const inBody = caret >= r.bodyStart && caret < r.bodyEnd;
      if (inHead || inBody) return r.name;
    }
    // fallback to first defined rule
    return ruleIdx.list[0]?.name ?? null;
  }

  function reachableFrom(ruleIdx, startName) {
    const reach = new Set();
    if (!startName || !ruleIdx.byName.has(startName)) return reach;
    const q = [startName];
    while (q.length) {
      const n = q.shift();
      if (reach.has(n)) continue;
      reach.add(n);
      const r = ruleIdx.byName.get(n);
      if (!r) continue;
      for (const to of r.refs) if (!reach.has(to)) q.push(to);
    }
    return reach;
  }

  // ----- diagnostics (syntax-ish + spacing) -----
  function diagnosticsPlus(text, tokens) {
    const errors = [];
    const errIdx = new Set();
    const pushErr = (i, msg) => { if (!errIdx.has(i)) errors.push({ i, msg }); errIdx.add(i); };

    // A) Pair matching
    const stack = [];
    for (const t of tokens) {
      if (t.type === 'par' || t.type === 'br') {
        if (t.raw === '(' || t.raw === '[' || t.raw === '{') {
          stack.push(t);
        } else {
          const o = stack.pop();
          const ok =
            (o && o.raw === '(' && t.raw === ')') ||
            (o && o.raw === '[' && t.raw === ']') ||
            (o && o.raw === '{' && t.raw === '}');
          if (!ok) { pushErr(t.i, `Mismatched "${t.raw}"`); if (o) pushErr(o.i, `Mismatched "${o.raw}"`); }
        }
      }
    }
    for (const u of stack) pushErr(u.i, `Unclosed "${u.raw}"`);

    // B) Space around ()[]{}
    const isWS = (tok) => tok && tok.type === 'ws';
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i]; if (!(t.type === 'par' || t.type === 'br')) continue;
      const prev = tokens[i - 1], next = tokens[i + 1];
      if (t.raw === '(' || t.raw === '[' || t.raw === '{') {
        if (!isWS(next)) pushErr(t.i, `Add a space after "${t.raw}"`);
        if (prev && !isWS(prev)) pushErr(t.i, `Add a space before "${t.raw}"`);
      } else {
        if (!isWS(prev)) pushErr(t.i, `Add a space before "${t.raw}"`);
        if (next && !isWS(next)) pushErr(t.i, `Add a space after "${t.raw}"`);
      }
    }

    // C) Rule head must have '->' on same line (best-effort)
    const firstNonWSOnLine = (idx) => {
      // walk back to start of line
      let p = idx;
      while (p > 0 && text[p - 1] !== '\n') p--;
      // find first non-ws token at/after p
      for (const t of tokens) {
        if (t.end <= p) continue;
        if (t.start < p && t.end > p && t.type !== 'ws') return t; // spanning token (rare)
        if (t.start >= p && t.type !== 'ws') return t;
      }
      return null;
    };
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i]; if (t.type !== 'id') continue;
      const first = firstNonWSOnLine(t.start);
      if (first && first.i === t.i) {
        const lineEnd = text.indexOf('\n', t.end);
        const arrowPos = text.indexOf('->', t.end);
        const hasArrow = (arrowPos !== -1 && (lineEnd === -1 || arrowPos < lineEnd));
        if (!hasArrow) pushErr(t.i, `Missing "->" after rule head "${t.raw}"`);
      }
    }

    return { errors, errIdx };
  }



// ==== NL diagnostics (robust, no-throw) ====
function grammarNLDiagnostics(text, visibleTokens /* SmartEditor tokens */){
  // If no lexer, or no text, bail safely
  if (typeof GrammarLexer !== 'function' || !text) return { errors: [] };

  // Get a token list from the lexer in a tolerant way
  let toks = [];
  try {
    const L = new GrammarLexer(text);
    if (Array.isArray(L.tokens)) {
      toks = L.tokens;
    } else if (typeof L.nextTok === 'function') {
      // Pull tokens until exhausted
      let t;
      while ((t = L.nextTok())) toks.push(t);
    } else {
      return { errors: [] };
    }
  } catch (_e) {
    return { errors: [] }; // never break the editor
  }

  // Normalize token shape: ensure .type, .value, .start
  for (const t of toks) {
    if (t && typeof t.start !== 'number') {
      // Try common alternates; else approximate with 0 (won't crash)
      t.start = (typeof t.pos === 'number') ? t.pos :
                (typeof t.s   === 'number') ? t.s   : 0;
    }
  }

  const errors = [];
  let depth = 0;

  const isIgn = t => t && (t.type === 'WS' || t.type === 'CMT' || t.type === 'NL');

  const prevSig = (k) => {
    for (let p = k - 1; p >= 0; p--) if (!isIgn(toks[p])) return toks[p];
    return null;
  };
  const nextSig = (k) => {
    for (let n = k + 1; n < toks.length; n++) if (!isIgn(toks[n])) return toks[n];
    return null;
  };

  // Helpers to map NL.start → nearest visible token index
  function previousVisibleOnOrBefore(vis, start){
    if (!Array.isArray(vis) || !vis.length) return -1;
    // binary search guard: ensure vis is monotonic by start
    // (tokenize() already produces monotonic start, so typical case is fine)
    let lo = 0, hi = vis.length - 1, ans = -1;
    while (lo <= hi){
      const mid = (lo + hi) >> 1;
      if (vis[mid].start <= start){ ans = mid; lo = mid + 1; }
      else hi = mid - 1;
    }
    return ans;
  }
  function nearestVisibleTokenIndex(vis, start){
    if (!Array.isArray(vis) || !vis.length) return -1;
    let lo = 0, hi = vis.length - 1, ans = -1;
    while (lo <= hi){
      const mid = (lo + hi) >> 1;
      if (vis[mid].start >= start){ ans = mid; hi = mid - 1; }
      else lo = mid + 1;
    }
    if (ans !== -1) return ans;
    return previousVisibleOnOrBefore(vis, start);
  }

  // Consider extra “friendly” NL allowances to reduce false positives:
  // - after '->'
  // - after/before '|'
  // - after any paren/bracket, or anywhere inside (...) depth>0
  // - start/end of file
  for (let i = 0; i < toks.length; i++){
    const t = toks[i];

    if (t.type === 'OP') {
      if (t.value === '(' || t.value === '[' || t.value === '{') depth++;
      if (t.value === ')' || t.value === ']' || t.value === '}') depth = Math.max(0, depth - 1);
    }

    if (t.type !== 'NL') continue;

    const prev = prevSig(i);
    const next = nextSig(i);

    const afterArrow = prev && prev.type === 'OP' && prev.value === '->';
    const afterBar   = prev && prev.type === 'OP' && prev.value === '|';
    const beforeBar  = next && next.type === 'OP' && next.value === '|';
    const afterParenOrBracket = prev && prev.type === 'OP' && (
      prev.value === '(' || prev.value === ')' || prev.value === '[' || prev.value === ']'
    );
    const atFileEdge = (!prev || !next);
    const insideParens = depth > 0;
const prevIsNLorWS = prev && (prev.type === 'NL' || prev.type === 'WS');
const nextIsNLorWS = next && (next.type === 'NL' || next.type === 'WS');
const emptyLine = prevIsNLorWS && nextIsNLorWS;

    const allowed = afterArrow || afterBar || beforeBar || afterParenOrBracket || insideParens || atFileEdge || emptyLine;

    if (!allowed) {
      const k = nearestVisibleTokenIndex(visibleTokens, t.start);
      if (k !== -1) {
        errors.push({ i: visibleTokens[k].i, msg: "Unexpected newline here" });
      } else {
        const j = previousVisibleOnOrBefore(visibleTokens, t.start);
        if (j !== -1) errors.push({ i: visibleTokens[j].i, msg: "Unexpected newline here" });
      }
    }
  }

  return { errors };
}


  // ----- full analysis (tokens + rules + errors + reachability) -----

function analyze() {
  const text   = ui.src.value || '';
  const tokens = tokenize(text);                    // SmartEditor’s visible tokens (must have start/end)
  const { vars, rules } = collectSymbols(text);
  const ruleIdx         = buildRuleIndex(text, tokens, rules);
  const { errors, errIdx } = diagnosticsPlus(text, tokens);

  // NEW: NL policy errors from GrammarLexer
  const nlDiag = grammarNLDiagnostics(text, tokens);
  for (const e of nlDiag.errors) {
    // avoid duplicate messages on the same token index
    if (!errIdx.has(e.i)) {
      errors.push(e);
      errIdx.add(e.i);
    }
  }

  // active rule & reachability (unchanged)
  const caret = ui.src.selectionStart ?? 0;
  const active = caretActiveRule(text, tokens, ruleIdx, caret);
  const reach  = reachableFrom(ruleIdx, active || ruleIdx.list[0]?.name);

  return { text, tokens, vars, rules, ruleIdx, errors, errIdx, active, reach };
}

  // ----- renderers (visible and hit layers) -----
  function classifyRuleSpan(t, A) {
    // t is an id token; decide def/ref + reachability classes
    let cls = '';
    const defTokIndex = A.ruleIdx.byName.get(t.raw)?.defIndex;
    const isDef = defTokIndex === t.i;
    if (isDef) cls += ' se-rule-def';
    else       cls += ' se-rule-ref';
    if (A.reach.has(t.raw)) cls += ' se-reach';
    else                    cls += ' se-unreach';
    if (isDef && A.active === t.raw) cls += ' se-active';
    return cls;
  }

  function renderLayer(targetEl, A) {
    const errMsgByIndex = new Map(A.errors.map(e => [e.i, e.msg]));
    let html = '';
    for (const t of A.tokens) {
      if (t.type === 'ws') { html += esc(t.raw); continue; }

      let cls = 'tok-op';
      switch (t.type) {
        case 'kw':  cls = 'tok-kw';    break;
        case 'num': cls = 'tok-num';   break;
        case 'par': cls = 'tok-paren'; break;
        case 'br':  cls = 'tok-brack'; break;
        case 'id':  cls = A.rules.has(t.raw) ? 'tok-rule' : 'tok-var'; break;
      }
      if (A.errIdx.has(t.i)) cls += ' err-squiggle';
      if (t.type === 'id' && (A.rules.has(t.raw))) cls += classifyRuleSpan(t, A);

      const msg = errMsgByIndex.get(t.i);
      const ds  = ` data-type="${t.type}" data-i="${t.i}" data-s="${t.start}" data-e="${t.end}"` +
                  (msg ? ` data-err="${esc(msg)}"` : '');
      html += `<span class="${cls}"${ds}>${esc(t.raw)}</span>`;
    }
    targetEl.innerHTML = html + '\n';
  }

  function renderBoth() {
    const A = analyze();
    renderLayer(ui.hl, A);
    renderLayer(ui.hitPre, A);

    const status = document.getElementById('status');
    if (status) {
      const n = A.errors.length;
      const reachInfo = A.active ? ` · Start: ${A.active} · Reachable: ${A.reach.size}` : '';
      status.textContent = n ? `⚠ ${n} issue${n>1?'s':''}${reachInfo}` : `Ready.${reachInfo}`;
    }
  }

  // ----- scroll & wrap sync -----
  function syncScroll() {
    const t = -ui.src.scrollTop + 'px';
    const l = -ui.src.scrollLeft + 'px';
    ui.hl.style.top = t;   ui.hl.style.left = l;
    ui.hitPre.style.top = t; ui.hitPre.style.left = l;
  }
  function setWrap(on) {
    if (ui.wrapBtn) ui.wrapBtn.textContent = on ? '⤶ Wrap: On' : '⤶ Wrap: Off';
    document.body.classList.toggle('wrap-on', !!on);
    ui.src.setAttribute('wrap', on ? 'soft' : 'off');
    ui.src.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    ui.hl.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    ui.hitPre.style.whiteSpace = on ? 'pre-wrap' : 'pre';
    if (on) ui.src.scrollLeft = 0;
    requestPaint('wrap');
  }

  // ----- tooltip (errors take precedence) -----
  function spanAtPoint(x, y) {
    ui.hit.style.pointerEvents = 'auto';
    const el = document.elementFromPoint(x, y);
    ui.hit.style.pointerEvents = 'none';
    return (el && el.tagName === 'SPAN' && el.closest('#se-hit-pre')) ? el : null;
  }
function showTipForSpan(span, clientX, clientY) {
  const err = span.dataset.err;
  const type = span.dataset.type;
  const raw  = span.textContent;

  let msg = err;
  if (!msg) {
    if (type === "kw") {
      msg = GRAMMAR_TOOLTIPS[raw] || `Keyword: ${raw}`;
    } else {
      switch (type) {
        case "num": msg = `Number: ${raw}`; break;
        case "id":  msg = `Identifier: ${raw}`; break;
        case "op":  msg = `Operator: ${raw}`; break;
        case "par": msg = `Parenthesis: ${raw}`; break;
        case "br":  msg = `Bracket: ${raw}`; break;
        default:    msg = raw; break;
      }
    }
  }

  ui.tip.textContent = msg;
  ui.tip.classList.toggle("is-error", !!err);

  const pad = 10;
  ui.tip.style.left = (clientX + pad) + "px";
  ui.tip.style.top  = (clientY + pad + 8) + "px";
  ui.tip.style.display = "block";
}
  function hideTip() { ui.tip.style.display = 'none'; }

  // ----- paint pipeline -----
  let raf = 0;
  function requestPaint(reason) {
    if (raf) return;
    raf = requestAnimationFrame(() => {
      raf = 0;
      cloneMetrics();
      renderBoth();
      syncScroll();
      // log(`[SE repaint] ${reason}`);
    });
  }

  // ----- events (bound once) -----
  ui.src.addEventListener('input', () => requestPaint('input'));
  ui.src.addEventListener('scroll', () => { syncScroll(); hideTip(); }, { passive: true });
  window.addEventListener('resize', () => requestPaint('resize'));
  if ('ResizeObserver' in window) new ResizeObserver(() => requestPaint('resize-observer')).observe(ui.src);

  // update reachability on caret moves too
  ui.src.addEventListener('keyup',  () => requestPaint('caret'));
  ui.src.addEventListener('click',  () => requestPaint('caret'));
  ui.src.addEventListener('blur',   hideTip);

  if (ui.wrapBtn) {
    let wrapped = document.body.classList.contains('wrap-on');
    ui.wrapBtn.addEventListener('click', () => { wrapped = !wrapped; setWrap(wrapped); });
  }

  // hover/tips
  wrap.addEventListener('mousemove', (e) => {
    const span = spanAtPoint(e.clientX, e.clientY);
    if (span) showTipForSpan(span, e.clientX, e.clientY);
    else hideTip();
  });
  wrap.addEventListener('mouseleave', hideTip);
  wrap.addEventListener('mousedown', () => { ui.hit.style.pointerEvents = 'none'; }, true);
  wrap.addEventListener('mouseup',   () => { ui.hit.style.pointerEvents = 'none'; }, true);

  // ----- public API (optional) -----
  window.SmartEditor = {
    refresh: () => requestPaint('api-refresh'),
    setWrap,
    analyze, // expose for debugging
  };

  // ----- boot -----
  setWrap(false);
  requestPaint('init');
  console.info('[SmartEditor] Ready.');
})();
            </script>    
    
            <script>       
            /*  Grammar Fragments */
(function(){
  const $ = (id) => document.getElementById(id);
  const src = $('src');
  const out = $('out');
  const statusEl = $('status');
  const nameInput = $('nameId');
  const saveBtn = $('saveBtn');

// refs
const chooser = document.getElementById('nameChooser');

// build dropdown from localStorage 'grammar_saves'
function refreshChooser(selectedId){
  if(!chooser) return;
  const saves = loadSaves();
  const ids = Object.keys(saves).sort((a,b)=>{
    const da = Date.parse(saves[a]?.saved_at||0) || 0;
    const db = Date.parse(saves[b]?.saved_at||0) || 0;
    return db - da || a.localeCompare(b);
  });

  chooser.innerHTML = '';
  const opt0 = document.createElement('option');
  opt0.value = '';
  opt0.textContent = ids.length ? 'Choose saved…' : 'No saved entries';
  opt0.disabled = true; opt0.selected = true;
  chooser.appendChild(opt0);

  ids.forEach(id=>{
    const o = document.createElement('option');
    o.value = id; o.textContent = id;
    if (selectedId && id === selectedId) o.selected = true;
    chooser.appendChild(o);
  });
}

// load on selection
chooser?.addEventListener('change', ()=>{
  const id = chooser.value;
  const saves = loadSaves();
  const entry = saves[id];
  if(!entry){  return; }
  if (nameInput) nameInput.value = id;
  if (src){
    src.value = entry.input_grammar || '';
    // let your highlighter update if it listens to 'input'
    src.dispatchEvent(new Event('input', {bubbles:true}));
  }
  statusEl && (statusEl.textContent = 'Loaded.');

});

// call once on init and after every save
refreshChooser();

  

  function loadSaves(){
    try{
      const raw = localStorage.getItem('grammar_saves');
      if(!raw) return {};
      const parsed = JSON.parse(raw);
      return (parsed && typeof parsed === 'object') ? parsed : {};
    }catch(e){
      console.warn('Failed to parse grammar_saves:', e);
      return {};
    }
  }
  function persistSaves(obj){
    try{ localStorage.setItem('grammar_saves', JSON.stringify(obj, null, 2)); }
    catch(e){ console.warn('Failed to persist grammar_saves:', e); }
  }



  function sanitizeName(s){
    return String(s||'').toLowerCase().trim()
      .replace(/[^a-z0-9-_]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 80);
  }
  function genRandomId(){
    return 'id_' + Math.random().toString(36).slice(2,7) + Math.floor(Math.random()*1e6).toString(36);
  }
  function timestampCompact(){
    const d=new Date();
    const p=n=>String(n).padStart(2,'0');
    return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}-${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}`;
  }
  function downloadJSON(filename, text){
    const blob = new Blob([text], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

  saveBtn?.addEventListener('click', ()=>{
    const saves = loadSaves();

    const userName = sanitizeName(nameInput?.value);
    const base = userName || genRandomId();
    let id = base;

    if (Object.prototype.hasOwnProperty.call(saves, id)) {
      id = `${base}-${timestampCompact()}`;
    }

    const entry = {
      unique_name_identifier: id,
      saved_at: new Date().toISOString(),
      input_grammar: String(src?.value ?? '')
    };

    saves[id] = entry;

    const jsonText = JSON.stringify(saves, null, 2);
    persistSaves(saves);
// inside your existing save handler, after persistSaves(saves):
 refreshChooser(id);
    downloadJSON('grammar_saves.json', jsonText);

    if (nameInput) namechooser.value = id;
    if (statusEl) statusEl.textContent = 'Saved.';

  });
})();
            </script>    
    
    
    
    


        
        <script type="text/javascript" src="https://34.69.10.227/static/js/site.js"></script>
        <!-- AOS script -->
        <script src="./Grammar Reader WebGLr - Progen3d Visual Design_files/aos.js.download" integrity="sha384-n1AULnKdMJlK1oQCLNDL9qZsDgXtH6jRYFCpBtWFc+a9Yve0KSoMn575rk755NJZ" crossorigin="anonymous"></script>
         <script>
            AOS.init();
         </script>
        
        
        

         <script src="./Grammar Reader WebGLr - Progen3d Visual Design_files/bootstrap.bundle.min.js.download" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
          <script type="" src="https://34.69.10.227/static/js/site.js"></script>
    

<div class="progress-container"><div class="progress-bar" style="width: 0%;"></div></div><div class="progress-container"><div class="progress-bar" style="width: 0%;"></div></div></body></html>